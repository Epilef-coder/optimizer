<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>sidermit.optimization API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sidermit.optimization</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .operators_cost import OperatorsCost
from .infrastructure_cost import InfrastructureCost
from .constrains import Constrains
from .users_cost import UsersCost
from .optimizer import Optimizer

__all__ = [&#39;OperatorsCost&#39;, &#39;Constrains&#39;, &#39;InfrastructureCost&#39;, &#39;UsersCost&#39;, &#39;Optimizer&#39;]</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="sidermit.optimization.constrains" href="constrains.html">sidermit.optimization.constrains</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="sidermit.optimization.infrastructure_cost" href="infrastructure_cost.html">sidermit.optimization.infrastructure_cost</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="sidermit.optimization.operators_cost" href="operators_cost.html">sidermit.optimization.operators_cost</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="sidermit.optimization.optimizer" href="optimizer.html">sidermit.optimization.optimizer</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="sidermit.optimization.preoptimization" href="preoptimization/index.html">sidermit.optimization.preoptimization</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="sidermit.optimization.users_cost" href="users_cost.html">sidermit.optimization.users_cost</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sidermit.optimization.Constrains"><code class="flex name class">
<span>class <span class="ident">Constrains</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Constrains:

    @staticmethod
    def most_loaded_section_constrains(routes: List[Route], most_loaded_section: defaultdict_float) -&gt; List[float]:
        &#34;&#34;&#34;
        to get constrains to optimization problem with respect to most loaded section for each routes
        :param most_loaded_section: dict with most loaded section for each route_id
        :param routes: list of Route object
        :return: list with constrains
        &#34;&#34;&#34;

        ineq_constrains = []

        for route in routes:
            kmax = route.mode.kmax
            max_loaded_section = most_loaded_section[route.id]

            ineq_constrains.append(max_loaded_section - kmax)

        return ineq_constrains

    @staticmethod
    def fmax_constrains(graph_obj: Graph, routes: List[Route], list_mode: List[TransportMode], f: defaultdict_float) -&gt; \
            List[float]:
        &#34;&#34;&#34;
        to get constrains about fmax in each edge in the network with respect to capacity in stop of the each mode
        :param graph_obj: Graph object
        :param routes: list of Route object
        :param list_mode: list TransportMode object
        :param f: dict with frequency for each route_id
        :return: list with constrains
        &#34;&#34;&#34;

        ineq_constrain = []

        edges = graph_obj.get_edges()

        for edge in edges:
            nodei = edge.node1.id
            nodej = edge.node2.id
            for mode in list_mode:
                fmax = mode.fmax
                sum_f = 0
                for route in routes:
                    if route.mode == mode:
                        if f[route.id] != 0:
                            node_sequence_i = route.nodes_sequence_i
                            node_sequence_r = route.nodes_sequence_r

                            for i in range(len(node_sequence_i) - 1):
                                j = i + 1
                                if str(nodei) == str(node_sequence_i[i]) and str(nodej) == str(node_sequence_i[j]):
                                    sum_f += f[route.id] / mode.d

                            for i in range(len(node_sequence_r) - 1):
                                j = i + 1
                                if str(nodei) == str(node_sequence_r[i]) and str(nodej) == str(node_sequence_r[j]):
                                    sum_f += f[route.id] / mode.d
                ineq_constrain.append(sum_f - fmax)

        return ineq_constrain</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sidermit.optimization.Constrains.fmax_constrains"><code class="name flex">
<span>def <span class="ident">fmax_constrains</span></span>(<span>graph_obj: <a title="sidermit.city.graph.Graph" href="../city/graph.html#sidermit.city.graph.Graph">Graph</a>, routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], list_mode: List[<a title="sidermit.publictransportsystem.mode.TransportMode" href="../publictransportsystem/mode.html#sidermit.publictransportsystem.mode.TransportMode">TransportMode</a>], f: defaultdict(<class 'float'>, {})) ‑> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>to get constrains about fmax in each edge in the network with respect to capacity in stop of the each mode
:param graph_obj: Graph object
:param routes: list of Route object
:param list_mode: list TransportMode object
:param f: dict with frequency for each route_id
:return: list with constrains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def fmax_constrains(graph_obj: Graph, routes: List[Route], list_mode: List[TransportMode], f: defaultdict_float) -&gt; \
        List[float]:
    &#34;&#34;&#34;
    to get constrains about fmax in each edge in the network with respect to capacity in stop of the each mode
    :param graph_obj: Graph object
    :param routes: list of Route object
    :param list_mode: list TransportMode object
    :param f: dict with frequency for each route_id
    :return: list with constrains
    &#34;&#34;&#34;

    ineq_constrain = []

    edges = graph_obj.get_edges()

    for edge in edges:
        nodei = edge.node1.id
        nodej = edge.node2.id
        for mode in list_mode:
            fmax = mode.fmax
            sum_f = 0
            for route in routes:
                if route.mode == mode:
                    if f[route.id] != 0:
                        node_sequence_i = route.nodes_sequence_i
                        node_sequence_r = route.nodes_sequence_r

                        for i in range(len(node_sequence_i) - 1):
                            j = i + 1
                            if str(nodei) == str(node_sequence_i[i]) and str(nodej) == str(node_sequence_i[j]):
                                sum_f += f[route.id] / mode.d

                        for i in range(len(node_sequence_r) - 1):
                            j = i + 1
                            if str(nodei) == str(node_sequence_r[i]) and str(nodej) == str(node_sequence_r[j]):
                                sum_f += f[route.id] / mode.d
            ineq_constrain.append(sum_f - fmax)

    return ineq_constrain</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Constrains.most_loaded_section_constrains"><code class="name flex">
<span>def <span class="ident">most_loaded_section_constrains</span></span>(<span>routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], most_loaded_section: defaultdict(<class 'float'>, {})) ‑> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>to get constrains to optimization problem with respect to most loaded section for each routes
:param most_loaded_section: dict with most loaded section for each route_id
:param routes: list of Route object
:return: list with constrains</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def most_loaded_section_constrains(routes: List[Route], most_loaded_section: defaultdict_float) -&gt; List[float]:
    &#34;&#34;&#34;
    to get constrains to optimization problem with respect to most loaded section for each routes
    :param most_loaded_section: dict with most loaded section for each route_id
    :param routes: list of Route object
    :return: list with constrains
    &#34;&#34;&#34;

    ineq_constrains = []

    for route in routes:
        kmax = route.mode.kmax
        max_loaded_section = most_loaded_section[route.id]

        ineq_constrains.append(max_loaded_section - kmax)

    return ineq_constrains</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sidermit.optimization.InfrastructureCost"><code class="flex name class">
<span>class <span class="ident">InfrastructureCost</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InfrastructureCost:
    @staticmethod
    def get_mode_network_distance(graph_obj: Graph, network_obj: TransportNetwork,
                                  f: defaultdict_float) -&gt; defaultdict_float:
        &#34;&#34;&#34;
        to get total distance builded in each transport mode
        :param network_obj: TransportNetwork object
        :param graph_obj: Graph object
        :param f: dict with frequency for each route_id
        :return: ddict with total distance for each mode in transport network
        &#34;&#34;&#34;
        edges = graph_obj.get_edges()
        edges_distance = graph_obj.get_edges_distance()

        routes = network_obj.get_routes()
        list_modes = network_obj.get_modes()

        mode_distance = defaultdict(float)

        for mode in list_modes:
            edge_list = []
            for edge in edges:
                d_e = edges_distance[edge.node1.id][edge.node2.id]
                for route in routes:
                    if route.mode == mode:
                        if f[route.id] != 0:
                            node_sequence_i = route.nodes_sequence_i
                            node_sequence_r = route.nodes_sequence_r

                            ver_sum = False
                            for i in range(len(node_sequence_i) - 1):
                                j = i + 1
                                if node_sequence_i[i] == edge.node1.id and node_sequence_i[j] == edge.node2.id and (
                                        edge.node1.id, edge.node2.id) not in edge_list:
                                    mode_distance[mode] += d_e * mode.d
                                    edge_list.append((edge.node1.id, edge.node2.id))
                                    edge_list.append((edge.node2.id, edge.node1.id))
                                    ver_sum = True
                                    break
                            if ver_sum is True:
                                break
                            for i in range(len(node_sequence_r) - 1):
                                j = i + 1
                                if node_sequence_r[i] == edge.node1.id and node_sequence_r[j] == edge.node2.id and (
                                        edge.node1.id, edge.node2.id) not in edge_list:
                                    mode_distance[mode] += d_e * mode.d
                                    edge_list.append((edge.node1.id, edge.node2.id))
                                    edge_list.append((edge.node2.id, edge.node1.id))
                                    ver_sum = True
                                    break
                            if ver_sum is True:
                                break

        return mode_distance

    @staticmethod
    def get_infrastruture_cost(graph_obj: Graph, network_obj: TransportNetwork, f: defaultdict_float) -&gt; float:
        &#34;&#34;&#34;
        to get infrastruture cost
        :param network_obj: TransportNetwork object
        :param graph_obj: Graph object
        :param f: dict with frequency for each route_id
        :return: infrastruture cost
        &#34;&#34;&#34;

        infrastruture_cost_obj = InfrastructureCost()

        mode_distance = infrastruture_cost_obj.get_mode_network_distance(graph_obj, network_obj, f)

        CI = 0

        for mode in mode_distance:
            CI += mode.c2 * mode_distance[mode]
        return CI</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sidermit.optimization.InfrastructureCost.get_infrastruture_cost"><code class="name flex">
<span>def <span class="ident">get_infrastruture_cost</span></span>(<span>graph_obj: <a title="sidermit.city.graph.Graph" href="../city/graph.html#sidermit.city.graph.Graph">Graph</a>, network_obj: <a title="sidermit.publictransportsystem.network.TransportNetwork" href="../publictransportsystem/network.html#sidermit.publictransportsystem.network.TransportNetwork">TransportNetwork</a>, f: defaultdict(<class 'float'>, {})) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get infrastruture cost
:param network_obj: TransportNetwork object
:param graph_obj: Graph object
:param f: dict with frequency for each route_id
:return: infrastruture cost</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_infrastruture_cost(graph_obj: Graph, network_obj: TransportNetwork, f: defaultdict_float) -&gt; float:
    &#34;&#34;&#34;
    to get infrastruture cost
    :param network_obj: TransportNetwork object
    :param graph_obj: Graph object
    :param f: dict with frequency for each route_id
    :return: infrastruture cost
    &#34;&#34;&#34;

    infrastruture_cost_obj = InfrastructureCost()

    mode_distance = infrastruture_cost_obj.get_mode_network_distance(graph_obj, network_obj, f)

    CI = 0

    for mode in mode_distance:
        CI += mode.c2 * mode_distance[mode]
    return CI</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.InfrastructureCost.get_mode_network_distance"><code class="name flex">
<span>def <span class="ident">get_mode_network_distance</span></span>(<span>graph_obj: <a title="sidermit.city.graph.Graph" href="../city/graph.html#sidermit.city.graph.Graph">Graph</a>, network_obj: <a title="sidermit.publictransportsystem.network.TransportNetwork" href="../publictransportsystem/network.html#sidermit.publictransportsystem.network.TransportNetwork">TransportNetwork</a>, f: defaultdict(<class 'float'>, {}))</span>
</code></dt>
<dd>
<div class="desc"><p>to get total distance builded in each transport mode
:param network_obj: TransportNetwork object
:param graph_obj: Graph object
:param f: dict with frequency for each route_id
:return: ddict with total distance for each mode in transport network</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_mode_network_distance(graph_obj: Graph, network_obj: TransportNetwork,
                              f: defaultdict_float) -&gt; defaultdict_float:
    &#34;&#34;&#34;
    to get total distance builded in each transport mode
    :param network_obj: TransportNetwork object
    :param graph_obj: Graph object
    :param f: dict with frequency for each route_id
    :return: ddict with total distance for each mode in transport network
    &#34;&#34;&#34;
    edges = graph_obj.get_edges()
    edges_distance = graph_obj.get_edges_distance()

    routes = network_obj.get_routes()
    list_modes = network_obj.get_modes()

    mode_distance = defaultdict(float)

    for mode in list_modes:
        edge_list = []
        for edge in edges:
            d_e = edges_distance[edge.node1.id][edge.node2.id]
            for route in routes:
                if route.mode == mode:
                    if f[route.id] != 0:
                        node_sequence_i = route.nodes_sequence_i
                        node_sequence_r = route.nodes_sequence_r

                        ver_sum = False
                        for i in range(len(node_sequence_i) - 1):
                            j = i + 1
                            if node_sequence_i[i] == edge.node1.id and node_sequence_i[j] == edge.node2.id and (
                                    edge.node1.id, edge.node2.id) not in edge_list:
                                mode_distance[mode] += d_e * mode.d
                                edge_list.append((edge.node1.id, edge.node2.id))
                                edge_list.append((edge.node2.id, edge.node1.id))
                                ver_sum = True
                                break
                        if ver_sum is True:
                            break
                        for i in range(len(node_sequence_r) - 1):
                            j = i + 1
                            if node_sequence_r[i] == edge.node1.id and node_sequence_r[j] == edge.node2.id and (
                                    edge.node1.id, edge.node2.id) not in edge_list:
                                mode_distance[mode] += d_e * mode.d
                                edge_list.append((edge.node1.id, edge.node2.id))
                                edge_list.append((edge.node2.id, edge.node1.id))
                                ver_sum = True
                                break
                        if ver_sum is True:
                            break

    return mode_distance</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sidermit.optimization.OperatorsCost"><code class="flex name class">
<span>class <span class="ident">OperatorsCost</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class OperatorsCost:

    @staticmethod
    def lines_travel_time(routes: List[Route], edge_distance: defaultdict2_float) -&gt; defaultdict_float:
        &#34;&#34;&#34;
        to get a dictionary with travel times for all lines defined in the network
        :param edge_distance: dict with edge distance [m], with 2 keys dic[nodei_id][nodej_id]= distance [m]
        :param routes: list of Route object
        :return: dict with time on board [hr] of vehicle for each route_id
        &#34;&#34;&#34;
        line_travel_time = defaultdict(float)

        for route in routes:
            node_sequence_i = route.nodes_sequence_i
            node_sequence_r = route.nodes_sequence_r

            tv = 0

            # recorremos secuencia de ida
            for i in range(len(node_sequence_i) - 1):
                j = i + 1

                nodei_id = node_sequence_i[i]
                nodej_id = node_sequence_i[j]

                tv += edge_distance[nodei_id][nodej_id] / route.mode.v

            # recorremos secuencia de vuelta
            for i in range(len(node_sequence_r) - 1):
                j = i + 1

                nodei_id = node_sequence_r[i]
                nodej_id = node_sequence_r[j]

                tv += edge_distance[nodei_id][nodej_id] / route.mode.v

            line_travel_time[route.id] = tv

        return line_travel_time

    @staticmethod
    def get_cycle_time(z: defaultdict3_float, v: defaultdict3_float, routes: List[Route],
                       line_travel_time: defaultdict_float) -&gt; defaultdict_float:
        &#34;&#34;&#34;
        to get cycle time of all routes in the network
        :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param routes: list of Route object
        :param line_travel_time: dict with time on board of vehicle for each route_id
        :return: dict with cycle time [hr] for each route_id
        &#34;&#34;&#34;

        cycle_time = defaultdict(float)

        for route in routes:
            route_id = route.id
            t = route.mode.t / 3600

            tc = line_travel_time[route_id]

            # secuancial
            if route.mode.bya == 0:

                for stop in z[route_id][&#34;I&#34;]:
                    tc += t * z[route_id][&#34;I&#34;][stop]
                for stop in v[route_id][&#34;I&#34;]:
                    tc += t * v[route_id][&#34;I&#34;][stop]
                for stop in z[route_id][&#34;R&#34;]:
                    tc += t * z[route_id][&#34;R&#34;][stop]
                for stop in v[route_id][&#34;R&#34;]:
                    tc += t * v[route_id][&#34;R&#34;][stop]

            # simultaneo
            if route.mode.bya == 1:
                processed_stop_i = []
                processed_stop_r = []

                for stop in z[route_id][&#34;I&#34;]:
                    processed_stop_i.append(stop)
                    tc += t * max(z[route_id][&#34;I&#34;][stop], v[route_id][&#34;I&#34;][stop])
                for stop in v[route_id][&#34;I&#34;]:
                    if stop not in processed_stop_i:
                        tc += t * max(z[route_id][&#34;I&#34;][stop], v[route_id][&#34;I&#34;][stop])
                for stop in z[route_id][&#34;R&#34;]:
                    processed_stop_r.append(stop)
                    tc += t * max(z[route_id][&#34;R&#34;][stop], v[route_id][&#34;R&#34;][stop])
                for stop in v[route_id][&#34;R&#34;]:
                    if stop not in processed_stop_r:
                        tc += t * max(z[route_id][&#34;R&#34;][stop], v[route_id][&#34;R&#34;][stop])

            cycle_time[route_id] = tc

        return cycle_time

    @staticmethod
    def get_operators_cost(routes: List[Route], cycle_time: defaultdict_float, f: defaultdict_float,
                           k: defaultdict_float) -&gt; float:
        &#34;&#34;&#34;
        to get operators cost give a frequencies and boarding size for all lines
        :param routes: list Route object
        :param cycle_time: dict with cycle time [hr] for each route_id
        :param f: dic[route_id] = frequency [veh/hr]
        :param k: dic[route_id] = frequency [pax/veh]
        :return: float, operators cost
        &#34;&#34;&#34;

        CO = 0

        for route in routes:
            route_id = route.id

            f_r = f[route_id]

            if f_r == 0:
                continue

            k_r = k[route_id]
            tc_r = cycle_time[route_id]

            mode = route.mode
            c0 = mode.co
            c1 = mode.c1

            CO += (c0 + c1 * k_r) * f_r * tc_r

        return CO</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sidermit.optimization.OperatorsCost.get_cycle_time"><code class="name flex">
<span>def <span class="ident">get_cycle_time</span></span>(<span>z: defaultdict(<function <lambda> at 0x10628420>, {}), v: defaultdict(<function <lambda> at 0x10628420>, {}), routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], line_travel_time: defaultdict(<class 'float'>, {}))</span>
</code></dt>
<dd>
<div class="desc"><p>to get cycle time of all routes in the network
:param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param routes: list of Route object
:param line_travel_time: dict with time on board of vehicle for each route_id
:return: dict with cycle time [hr] for each route_id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_cycle_time(z: defaultdict3_float, v: defaultdict3_float, routes: List[Route],
                   line_travel_time: defaultdict_float) -&gt; defaultdict_float:
    &#34;&#34;&#34;
    to get cycle time of all routes in the network
    :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param routes: list of Route object
    :param line_travel_time: dict with time on board of vehicle for each route_id
    :return: dict with cycle time [hr] for each route_id
    &#34;&#34;&#34;

    cycle_time = defaultdict(float)

    for route in routes:
        route_id = route.id
        t = route.mode.t / 3600

        tc = line_travel_time[route_id]

        # secuancial
        if route.mode.bya == 0:

            for stop in z[route_id][&#34;I&#34;]:
                tc += t * z[route_id][&#34;I&#34;][stop]
            for stop in v[route_id][&#34;I&#34;]:
                tc += t * v[route_id][&#34;I&#34;][stop]
            for stop in z[route_id][&#34;R&#34;]:
                tc += t * z[route_id][&#34;R&#34;][stop]
            for stop in v[route_id][&#34;R&#34;]:
                tc += t * v[route_id][&#34;R&#34;][stop]

        # simultaneo
        if route.mode.bya == 1:
            processed_stop_i = []
            processed_stop_r = []

            for stop in z[route_id][&#34;I&#34;]:
                processed_stop_i.append(stop)
                tc += t * max(z[route_id][&#34;I&#34;][stop], v[route_id][&#34;I&#34;][stop])
            for stop in v[route_id][&#34;I&#34;]:
                if stop not in processed_stop_i:
                    tc += t * max(z[route_id][&#34;I&#34;][stop], v[route_id][&#34;I&#34;][stop])
            for stop in z[route_id][&#34;R&#34;]:
                processed_stop_r.append(stop)
                tc += t * max(z[route_id][&#34;R&#34;][stop], v[route_id][&#34;R&#34;][stop])
            for stop in v[route_id][&#34;R&#34;]:
                if stop not in processed_stop_r:
                    tc += t * max(z[route_id][&#34;R&#34;][stop], v[route_id][&#34;R&#34;][stop])

        cycle_time[route_id] = tc

    return cycle_time</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.OperatorsCost.get_operators_cost"><code class="name flex">
<span>def <span class="ident">get_operators_cost</span></span>(<span>routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], cycle_time: defaultdict(<class 'float'>, {}), f: defaultdict(<class 'float'>, {}), k: defaultdict(<class 'float'>, {})) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get operators cost give a frequencies and boarding size for all lines
:param routes: list Route object
:param cycle_time: dict with cycle time [hr] for each route_id
:param f: dic[route_id] = frequency [veh/hr]
:param k: dic[route_id] = frequency [pax/veh]
:return: float, operators cost</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_operators_cost(routes: List[Route], cycle_time: defaultdict_float, f: defaultdict_float,
                       k: defaultdict_float) -&gt; float:
    &#34;&#34;&#34;
    to get operators cost give a frequencies and boarding size for all lines
    :param routes: list Route object
    :param cycle_time: dict with cycle time [hr] for each route_id
    :param f: dic[route_id] = frequency [veh/hr]
    :param k: dic[route_id] = frequency [pax/veh]
    :return: float, operators cost
    &#34;&#34;&#34;

    CO = 0

    for route in routes:
        route_id = route.id

        f_r = f[route_id]

        if f_r == 0:
            continue

        k_r = k[route_id]
        tc_r = cycle_time[route_id]

        mode = route.mode
        c0 = mode.co
        c1 = mode.c1

        CO += (c0 + c1 * k_r) * f_r * tc_r

    return CO</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.OperatorsCost.lines_travel_time"><code class="name flex">
<span>def <span class="ident">lines_travel_time</span></span>(<span>routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], edge_distance: defaultdict(<function <lambda> at 0x106297C8>, {}))</span>
</code></dt>
<dd>
<div class="desc"><p>to get a dictionary with travel times for all lines defined in the network
:param edge_distance: dict with edge distance [m], with 2 keys dic[nodei_id][nodej_id]= distance [m]
:param routes: list of Route object
:return: dict with time on board [hr] of vehicle for each route_id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def lines_travel_time(routes: List[Route], edge_distance: defaultdict2_float) -&gt; defaultdict_float:
    &#34;&#34;&#34;
    to get a dictionary with travel times for all lines defined in the network
    :param edge_distance: dict with edge distance [m], with 2 keys dic[nodei_id][nodej_id]= distance [m]
    :param routes: list of Route object
    :return: dict with time on board [hr] of vehicle for each route_id
    &#34;&#34;&#34;
    line_travel_time = defaultdict(float)

    for route in routes:
        node_sequence_i = route.nodes_sequence_i
        node_sequence_r = route.nodes_sequence_r

        tv = 0

        # recorremos secuencia de ida
        for i in range(len(node_sequence_i) - 1):
            j = i + 1

            nodei_id = node_sequence_i[i]
            nodej_id = node_sequence_i[j]

            tv += edge_distance[nodei_id][nodej_id] / route.mode.v

        # recorremos secuencia de vuelta
        for i in range(len(node_sequence_r) - 1):
            j = i + 1

            nodei_id = node_sequence_r[i]
            nodej_id = node_sequence_r[j]

            tv += edge_distance[nodei_id][nodej_id] / route.mode.v

        line_travel_time[route.id] = tv

    return line_travel_time</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sidermit.optimization.Optimizer"><code class="flex name class">
<span>class <span class="ident">Optimizer</span></span>
<span>(</span><span>graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger, network_obj: TransportNetwork, f: defaultdict_float = None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Optimizer:
    def __init__(self, graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger, network_obj: TransportNetwork,
                 f: defaultdict_float = None):

        # definimos ciudad
        self.graph_obj = graph_obj
        _, _, _, self.p, _, _, _, _, _ = self.graph_obj.get_parameters()
        # definimos demanda
        self.demand_obj = demand_obj
        self.total_trips = demand_obj.get_total_trips()
        # definimos pasajeros
        self.passenger_obj = passenger_obj
        self.vp = self.passenger_obj.va
        self.pa = self.passenger_obj.pa
        self.pv = self.passenger_obj.pv
        self.TP = self.passenger_obj.pt

        # definimos red de transporte
        self.network_obj = network_obj

        # definimos frecuencia
        self.f, self.f_opt, self.lines_position = self.f0(f)

        self.extended_graph_obj = ExtendedGraph(self.graph_obj, self.network_obj.get_routes(), self.TP, self.f)
        self.hyperpath_obj = Hyperpath(self.extended_graph_obj, self.passenger_obj)

        # en este punto se debería levantar exception de que la red tiene mas de dos modos defnidos
        # o que existe un par OD con viaje y sin conexion
        self.hyperpaths, self.labels, self.successors, self.frequency, self.Vij = self.hyperpath_obj.get_all_hyperpaths(
            self.demand_obj.get_matrix())

        self.assignment = Assignment.get_assignment(self.hyperpaths, self.labels, self.p, self.vp, self.pa,
                                                    self.pv)

        self.len_constrains = len(self.get_constrains(self.f_opt))
        self.len_var = len(self.f_opt)

        self.better_res = None  # (fopt, success, status, message, constr_violation, vrc)

    def f0(self, f: defaultdict_float = None) -&gt; (defaultdict_float, List[float], defaultdict_str):
        &#34;&#34;&#34;
        to get a relation between f as a dictionary and f_opt as a list to the optimizer
        :param f: dic[route_id] = frequency [veh/hr] for all D lines
        :return: dic[route_id] = frequency [veh/hr] for all D lines, List[frequency], dic[position] = route_id
        &#34;&#34;&#34;
        fini = defaultdict(float)
        fopt = []
        lines_position = defaultdict(None)
        n = 0
        if f is None:
            for route in self.network_obj.get_routes():
                fini[route.id] = route.mode.fini
                fopt.append(route.mode.fini)
                lines_position[n] = route.id
                n += 1
        else:
            for route in self.network_obj.get_routes():
                fini[route.id] = f[route.id]
                fopt.append(route.mode.fini)
                lines_position[n] = route.id
                n += 1

        return fini, fopt, lines_position

    def fopt_to_f(self, fopt: List[float]) -&gt; defaultdict_float:
        &#34;&#34;&#34;
        to get f as a dictionary
        :param fopt: List[frequency]
        :return: dic[route_id] = frequency [veh/hr] all D lines
        &#34;&#34;&#34;
        f = defaultdict(float)
        n = 0
        for fr in fopt:
            f[self.lines_position[n]] = fr
            n += 1
        return f

    @staticmethod
    def get_k(loaded_section_route: defaultdict3_float) -&gt; defaultdict_float:
        &#34;&#34;&#34;
        :param loaded_section_route: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :return: k: dic[route_id] = vehicle capacity [pax/veh]
        &#34;&#34;&#34;
        most_loaded_section = Assignment.most_loaded_section(loaded_section_route)
        k = defaultdict(float)
        for route_id in most_loaded_section:
            k[route_id] = most_loaded_section[route_id]
        return k

    def operators_cost(self, z: defaultdict3_float, v: defaultdict3_float, f: defaultdict_float,
                       k: defaultdict_float) -&gt; float:
        &#34;&#34;&#34;
        to get operators cost
        :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param f: dic[route_id] = frequency [veh/hr]
        :param k: dic[route_id] = frequency [pax/veh]
        :return: float, operator cost
        &#34;&#34;&#34;
        operators_cost_obj = OperatorsCost()

        edge_distance = self.graph_obj.get_edges_distance()
        routes = self.network_obj.get_routes()
        line_travel_time = operators_cost_obj.lines_travel_time(routes, edge_distance)

        cycle_time = operators_cost_obj.get_cycle_time(z, v, routes, line_travel_time)
        cost = operators_cost_obj.get_operators_cost(routes, cycle_time, f, k)
        return cost

    def infrastructure_cost(self, f: defaultdict_float) -&gt; float:
        &#34;&#34;&#34;
        to get infrastructure cost
        :param f: dic[route_id] = frequency [veh/hr]
        :return: float, infrastructure cost
        &#34;&#34;&#34;
        infrastructure_cost_obj = InfrastructureCost()
        cost = infrastructure_cost_obj.get_infrastruture_cost(self.graph_obj, self.network_obj, f)
        return cost

    def user_cost(self, hyperpaths: dic_hyperpaths, Vij: dic_Vij, assignment: dic_assigment,
                  successors: dic_successors, extended_graph: ExtendedGraph, f: defaultdict_float,
                  z: defaultdict3_float, v: defaultdict3_float) -&gt; float:
        &#34;&#34;&#34;
        to get users cost
        :param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
        :param Vij: dic[origin: CityNode][destination: CityNode] = vij
        :param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
        :param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
        :param extended_graph: ExtendedGraph object
        :param f: dict with frequency [veh/hr] for each route_id
        :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :return: float, users cost
        &#34;&#34;&#34;
        user_cost_obj = UsersCost()
        cost = user_cost_obj.get_users_cost(hyperpaths, Vij, assignment, successors, extended_graph, f,
                                            self.passenger_obj, z, v)
        return cost

    def constrains(self, loaded_section_route: defaultdict3_float, f: defaultdict_float) -&gt; (
            List[float], List[float]):
        &#34;&#34;&#34;
        to get k constrains and f constrains
        :param loaded_section_route: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param f: dict with frequency [veh/hr] for each route_id
        :return: (k_ineq_constrains, f_ineq_constrains)
        &#34;&#34;&#34;

        most_loaded_section = Assignment.most_loaded_section(loaded_section_route)

        constrains_obj = Constrains()

        ineq_k = constrains_obj.most_loaded_section_constrains(self.network_obj.get_routes(), most_loaded_section)
        ineq_f = constrains_obj.fmax_constrains(self.graph_obj, self.network_obj.get_routes(),
                                                self.network_obj.get_modes(), f)

        return ineq_k, ineq_f

    def VRC(self, fopt: List[float]) -&gt; float:
        &#34;&#34;&#34;
        to get VRC objective function to minime in optimizer
        :param fopt: variable to optimize
        :return: float, VRC value function
        &#34;&#34;&#34;

        f = self.fopt_to_f(fopt)

        z, v, loaded_section_route = Assignment.get_alighting_and_boarding(self.Vij, self.hyperpaths, self.successors,
                                                                           self.assignment, f)
        k = self.get_k(loaded_section_route)

        CO = self.operators_cost(z, v, f, k)
        CI = self.infrastructure_cost(f)
        CU = self.user_cost(self.hyperpaths, self.Vij, self.assignment, self.successors, self.extended_graph_obj, f, z,
                            v)

        return CO + CI + CU

    def get_constrains(self, fopt: List[float]) -&gt; List[float]:
        &#34;&#34;&#34;
        to get all constrains as a List[float]
        :param fopt: variable to optimize
        :return: all constrains as a List[float]
        &#34;&#34;&#34;

        f = self.fopt_to_f(fopt)

        z, v, loaded_section_route = Assignment.get_alighting_and_boarding(self.Vij, self.hyperpaths, self.successors,
                                                                           self.assignment, f)

        most_loaded_section = Assignment.most_loaded_section(loaded_section_route)
        constrain_obj = Constrains()
        ineq_k = constrain_obj.most_loaded_section_constrains(self.network_obj.get_routes(), most_loaded_section)
        ineq_f = constrain_obj.fmax_constrains(self.graph_obj, self.network_obj.get_routes(),
                                               self.network_obj.get_modes(), f)

        con = []
        for c in ineq_k:
            con.append(c)
        for c in ineq_f:
            con.append(c)

        return con

    def internal_optimization(self) -&gt; OptimizeResult:
        &#34;&#34;&#34;
        method to do internal optimization process, with a hyperpath setted you can get a optimization of the network
        :return:     res : OptimizeResult
        The optimization result represented as a ``OptimizeResult`` object.
        Important attributes are: ``x`` the solution array, ``success`` a
        Boolean flag indicating if the optimizer exited successfully and
        ``message`` which describes the cause of the termination. See
        `OptimizeResult` for a description of other attributes.
        &#34;&#34;&#34;

        constr_func = lambda fopt: np.array(self.get_constrains(fopt))

        lb = [-1 * np.inf] * self.len_constrains
        ub = [0] * self.len_constrains
        nonlin_con = NonlinearConstraint(constr_func, lb=lb, ub=ub)

        lb = [0] * self.len_var
        ub = [np.inf] * self.len_var

        bounds = Bounds(lb=lb, ub=ub)
        res = minimize(self.VRC, self.f_opt, method=&#39;trust-constr&#39;, constraints=nonlin_con, tol=0.01, bounds=bounds)
        logger.info(self.string_information_internal_optimization(res))

        return res

    @staticmethod
    def string_information_internal_optimization(res: OptimizeResult) -&gt; str:
        &#34;&#34;&#34;
        to get a string with information about internal optimization
        :param res: OptimizeResult
        :return: str
        &#34;&#34;&#34;

        success = res.success
        status = res.status
        message = res.message
        new_f = res.x
        constr_violation = res.constr_violation
        fun = res.fun

        line = &#34;Internal optimization\n\tSuccess: {}\n\tStatus: {}\n\tMessage: {}\n\tnew_f: {}\n\tConstrain violation: {}\n\tVRC: {}&#34;.format(
            success, status, message, new_f, constr_violation, fun)
        return line

    @staticmethod
    def f_distance(prev_f: List[float], new_f: List[float]) -&gt; float:
        &#34;&#34;&#34;
        to get distance between 2 list of frequency results.
        :param prev_f: previous frequency
        :param new_f: new frequency
        :return: float, distance with normal distance
        &#34;&#34;&#34;
        dif = 0
        for i in range(len(prev_f)):
            dif += abs(prev_f[i] - new_f[i])
        dif = dif  # ** (1 / len(prev_f))
        logger.info(&#34;f_norm_distance: {}&#34;.format(dif))
        return dif

    def external_optimization_tolerance(self, prev_f: List[float], new_f: List[float], tol: float = 0.01) -&gt; bool:
        &#34;&#34;&#34;
        True, if tolerance criteria is success
        :param prev_f: previous frequency
        :param new_f: new frequency
        :param tol: float, tolerance
        :return: True, if tolerance criteria is success
        &#34;&#34;&#34;

        if tol &gt; abs(self.f_distance(prev_f, new_f)):
            return True

        return False

    @staticmethod
    def status_optimization(better_res) -&gt; bool:
        &#34;&#34;&#34;
        to get a information about status of external optimization
        :param better_res:(fopt, success, status, message, constr_violation, vrc)
        :return: true if status is success, exceptions if not
        &#34;&#34;&#34;

        if better_res is None:
            raise NoOptimalSolutionFoundException(
                &#34;No optimal solution was found. You can try with other fini or total demand is very large for the proposed network.&#34;)

        fopt, success, status, message, constr_violation, fun = better_res

        for f in fopt:
            if f &lt; -0.1:
                raise NegativeFrequencyException(&#34;Solution with negative frequency. You can try with other fini&#34;)

        if abs(constr_violation) &gt; 0.1:
            raise ConstraintViolationException(
                &#34;Maximum constraint violation at the solution {}. You can try with other fini or total demand is very large for the proposed network.&#34;.format(
                    constr_violation))

        if status == 0 or status == 3:
            raise NoOptimalSolutionFoundException(
                &#34;No optimal solution was found. You can try with other fini or total demand is very large for the proposed network.&#34;)

        return True

    @staticmethod
    def external_optimization(graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger,
                              network_obj: TransportNetwork,
                              f: defaultdict_float = None, tolerance: float = 0.01,
                              number_of_iteration: int = None) -&gt; Tuple:
        &#34;&#34;&#34;
        method to do external optimization process, several iterations of internal optimization with fixed
        hyperpaths in each
        :param graph_obj: Graph object
        :param demand_obj: Demand object
        :param passenger_obj: Passenger object
        :param network_obj: TransportNetwork object
        :param f: dict with frequency [veh/hr] for each route_id, dic[route_id] = frequency
        :param tolerance: float, tolerance to external optimization
        :param number_of_iteration: int, max. number of iterations. Default value is infinity.
        it is recommended to set this value in a small number of iterations (e.x. 5) in the beginning to know if it
        converges
        :return: (fopt, success, status, message, constr_violation, vrc)
        &#34;&#34;&#34;

        list_res = []

        opt_obj = Optimizer(graph_obj, demand_obj, passenger_obj, network_obj, f)
        # inicialización
        list_res.append((opt_obj.f_opt, &#34;initialization&#34;, -1, &#34;initialization&#34;, -1, -1))

        # primera iteracion
        res = opt_obj.internal_optimization()
        list_res.append((res.x, res.success, res.status, res.message, res.constr_violation, res.fun))

        pre_f, _, _, _, _, _ = list_res[0]
        new_f, _, _, _, _, _ = list_res[1]

        iteration = 1
        # mientras criterio de tolerancia externo no se cumpla o se llegue al maximo numero de iteraciones
        while not opt_obj.external_optimization_tolerance(pre_f, new_f, tolerance):
            if number_of_iteration is not None:
                if iteration &gt; number_of_iteration:
                    break
            pre_f = new_f
            dic_new_f = opt_obj.fopt_to_f(new_f)
            opt_obj = Optimizer(graph_obj, demand_obj, passenger_obj, network_obj, dic_new_f)
            res = opt_obj.internal_optimization()
            list_res.append((res.x, res.success, res.status, res.message, res.constr_violation, res.fun))
            new_f = res.x
            iteration += 1

        better_result = opt_obj.get_better_result(list_res)

        if opt_obj.status_optimization(better_result):
            return better_result

    @staticmethod
    def get_better_result(list_res):
        valid_result = []
        for x, success, status, message, constr_violation, fun in list_res:
            if status not in [0, 3, -1] and abs(constr_violation) &lt; 0.001:
                cond_f = True
                for f in x:
                    if f &lt; 0:
                        cond_f = False
                        break
                if cond_f:
                    valid_result.append((x, success, status, message, constr_violation, fun))

        better_result = None
        max_fun = float(&#34;inf&#34;)
        for x, success, status, message, constr_violation, fun in valid_result:
            if fun &lt; max_fun:
                max_fun = fun
                better_result = (x, success, status, message, constr_violation, fun)

        return better_result

    @staticmethod
    def network_optimization(graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger,
                             network_obj: TransportNetwork,
                             f: defaultdict_float = None, tolerance: float = 0.01,
                             max_number_of_iteration: int = None) -&gt; Optimizer:
        &#34;&#34;&#34;
        obtain optimal frequency for the defined network if possible or raise exceptions in case of not being able
        :param graph_obj: Graph object
        :param demand_obj: Demand object
        :param passenger_obj: Passenger object
        :param network_obj: TransportNetwork object
        :param f: dict with frequency [veh/hr] for each route_id, dic[route_id] = frequency, if f is None then fini of
        each TransportMode defined in TransportNetwork define f.
        :param tolerance: float, tolerance to external optimization
        :param max_number_of_iteration: int, max. number of iterations. Default value is infinity.
        it is recommended to set this value in a small number of iterations (e.x. 5) in the beginning to know if it
        converges
        :return: opt_obj
        &#34;&#34;&#34;

        opt_obj = Optimizer(graph_obj, demand_obj, passenger_obj, network_obj, f)
        opt_obj.better_res = opt_obj.external_optimization(graph_obj, demand_obj, passenger_obj, network_obj, f,
                                                           tolerance, number_of_iteration=max_number_of_iteration)

        logger.info(opt_obj.string_network_optimization(opt_obj.better_res))

        return opt_obj

    def get_optimization_value(self) -&gt; Tuple:
        &#34;&#34;&#34;
        to get optimization value saved
        :return: (fopt, success, status, message, constr_violation, vrc)
        &#34;&#34;&#34;
        return self.better_res

    def string_network_optimization(self, res: Tuple) -&gt; str:
        &#34;&#34;&#34;
        get a str summary about last external optimization in network_optimization
        :param res: Tuple, (fopt, success, status, message, constr_violation, vrc)
        :return:
        &#34;&#34;&#34;
        fopt, success, status, message, constr_violation, vrc = res
        f = self.fopt_to_f(fopt)

        line = &#34;\n\nOptimization Results&#34;
        line += &#34;\nSuccess: {}&#34;.format(success)
        line += &#34;\nStatus: {}&#34;.format(status)
        line += &#34;\nMessage: {}&#34;.format(message)
        line += &#34;\nMax constrain violation: {}&#34;.format(constr_violation)
        line += &#34;\nVRC: {}&#34;.format(vrc)
        line += &#34;\n\nFrequency information [veh/hr]: &#34;
        for route_id in f:
            line += &#34;\n\t{}: {:.2f}&#34;.format(route_id, f[route_id])

        return line

    def last_iteration(self, res: Tuple):
        &#34;&#34;&#34;
        return last network optimized with optimization result
        :param res: res: Tuple, (fopt, success, status, message, constr_violation, vrc)
        :return: Optimizer object, boarding dictionary, alighting dictionary, k dictionary, loaded_section_route
        &#34;&#34;&#34;
        fopt, success, status, message, constr_violation, vrc = res
        f = self.fopt_to_f(fopt)
        final_optimizer = Optimizer(self.graph_obj, self.demand_obj, self.passenger_obj, self.network_obj, f)
        z, v, loaded_section_route = Assignment.get_alighting_and_boarding(final_optimizer.Vij,
                                                                           final_optimizer.hyperpaths,
                                                                           final_optimizer.successors,
                                                                           final_optimizer.assignment, f)
        k = self.get_k(loaded_section_route)
        return final_optimizer, z, v, k, loaded_section_route

    def get_network_results(self) -&gt; List[Tuple]:
        &#34;&#34;&#34;
        to get transport network results per line-direction
        :return: List[(route.id: str, f [veh/hr]: float, k [pax/veh]: float, B [veh]: float, cycle_time [hr]: float,
        CO [US$/hr-pax]: float, lambda_min, sub_table_i: List[(node_i, node_j, lambda)],
        sub_table_i: List[(node_i, node_j, lambda)]
        &#34;&#34;&#34;
        if self.better_res is not None:
            res = self.better_res
        else:
            raise NoOptimalSolutionFoundException(&#34;not solution found in optimizer object&#34;)

        output = []

        fopt, success, status, message, constr_violation, vrc = res
        final_optimizer, z, v, k, loaded_section_route = self.last_iteration(res)

        f = self.fopt_to_f(fopt)

        # resultados de modos
        travel_time_line = OperatorsCost.lines_travel_time(final_optimizer.network_obj.get_routes(),
                                                           final_optimizer.graph_obj.get_edges_distance())
        cycle_time_line = OperatorsCost.get_cycle_time(z, v, final_optimizer.network_obj.get_routes(), travel_time_line)

        for route in final_optimizer.network_obj.get_routes():

            # flota de buses
            b = cycle_time_line[route.id] * f[route.id]
            nodes_sequence_i = route.nodes_sequence_i
            nodes_sequence_r = route.nodes_sequence_r
            # carga que hay en los tramos
            total_pax = 0
            charge_i = []
            charge_r = []
            # total de subidas a la ruta
            total_b = 0

            # caso circular
            if route._type == RouteType.CIRCULAR:

                # circular con sentido de ida
                if len(nodes_sequence_i) &gt; 0:
                    node_sequence = nodes_sequence_i
                    direction = &#34;I&#34;
                # circular con sentido de vuelta
                else:
                    node_sequence = nodes_sequence_r
                    direction = &#34;R&#34;
                load_i = []
                for i in node_sequence:
                    for stop_node in z[route.id][direction]:
                        if stop_node.city_node.graph_node.id == i:
                            total_b += z[route.id][direction][stop_node]
                            break
                    for stop_node in loaded_section_route[route.id][direction]:
                        if stop_node.city_node.graph_node.id == i:
                            load_i.append(loaded_section_route[route.id][direction][stop_node])
                            break

                if total_b == 0:
                    co = 0
                else:
                    co = (route.mode.co + route.mode.c1 * k[route.id]) * f[route.id] * cycle_time_line[route.id] / (
                            total_b * f[route.id])

                if len(load_i) &gt;= 1:
                    charge_min = min(load_i) / max(load_i)
                else:
                    load_i = [1] * len(node_sequence)
                    charge_min = 0

                sub_table = []
                sub_table_i = []
                sub_table_r = []

                node_i = None
                charge_ij = None
                for i in range(len(node_sequence)):
                    if i == 0:
                        node_i = node_sequence[i]
                        charge_ij = load_i[i] / max(load_i)
                        continue
                    else:
                        node_j = node_sequence[i]
                        sub_table.append((node_i, node_j, abs(charge_ij)))
                        node_i = node_j
                        charge_ij = load_i[i] / max(load_i)

                # circular con sentido de ida
                if len(nodes_sequence_i) &gt; 0:
                    sub_table_i = sub_table
                # circular con sentido de vuelta
                else:
                    sub_table_r = sub_table

                output.append((
                    route.id, f[route.id], f[route.id] / route.mode.d, k[route.id], b, cycle_time_line[route.id] * 60,
                    co, abs(charge_min), sub_table_i, sub_table_r))
            else:
                # z and v: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
                total_pax = 0
                for node_id in nodes_sequence_i:
                    bool_add = False
                    for stopnode in z[route.id][&#34;I&#34;]:
                        if stopnode.city_node.graph_node.id == node_id:
                            pax_b = z[route.id][&#34;I&#34;][stopnode]
                            pax_a = v[route.id][&#34;I&#34;][stopnode]
                            total_pax += pax_b - pax_a
                            total_b += pax_b

                            charge_i.append((node_id, total_pax / k[route.id]))
                            bool_add = True
                            break
                    if bool_add is False:
                        charge_i.append((node_id, total_pax / k[route.id]))

                total_pax = 0
                for node_id in nodes_sequence_r:
                    bool_add = False
                    for stopnode in z[route.id][&#34;R&#34;]:
                        if stopnode.city_node.graph_node.id == node_id:
                            pax_b = z[route.id][&#34;R&#34;][stopnode]
                            pax_a = v[route.id][&#34;R&#34;][stopnode]
                            total_pax += pax_b - pax_a
                            total_b += pax_b

                            charge_r.append((node_id, total_pax / k[route.id]))
                            bool_add = True
                            break
                    if bool_add is False:
                        charge_r.append((node_id, total_pax / k[route.id]))

                co = (route.mode.co + route.mode.c1 * k[route.id]) * f[route.id] * cycle_time_line[route.id] / (
                        total_b * f[route.id])

                charge_min = float(&#34;inf&#34;)
                sub_table_i = []
                node_i = None
                charge_ij = None
                for node_j, charge in charge_i:
                    if node_i is None:
                        node_i = node_j
                        charge_ij = charge
                        continue
                    else:
                        sub_table_i.append((node_i, node_j, abs(charge_ij)))
                        if charge_min &gt; charge_ij:
                            charge_min = charge_ij
                        node_i = node_j
                        charge_ij = charge

                sub_table_r = []
                node_i = None
                charge_ij = None
                for node_j, charge in charge_r:
                    if node_i is None:
                        node_i = node_j
                        charge_ij = charge
                        continue
                    else:
                        sub_table_r.append((node_i, node_j, abs(charge_ij)))
                        if charge_min &gt; charge_ij:
                            charge_min = charge_ij
                        node_i = node_j
                        charge_ij = charge

                output.append((
                    route.id, f[route.id], f[route.id] / route.mode.d, k[route.id], b, cycle_time_line[route.id] * 60,
                    co, abs(charge_min), sub_table_i, sub_table_r))

        return output

    def string_network_results(self) -&gt; str:
        &#34;&#34;&#34;
        to get a string with network results
        :return: str
        &#34;&#34;&#34;

        output_network_results = self.get_network_results()
        line = &#34;route_id;F[veh/hr];f[veh/hr-line];k[pax/veh];B[veh];tc[min];CO[US$/hr-pax];load_min;sub_table_i;sub_table_r&#34;

        for route_id, F, f, k, b, cycle_time, co, charge_min, sub_table_i, sub_table_r in output_network_results:
            line += &#34;\n{};{:.2f};{:.2f};{:.2f};{:.2f};{:.2f};{:.2f};{:.2f};{};{}&#34;.format(route_id, F, f, k, b,
                                                                                         cycle_time, co,
                                                                                         charge_min, sub_table_i,
                                                                                         sub_table_r)
        return line

    def write_file_network_results(self, file_path) -&gt; None:
        &#34;&#34;&#34;
        to write output file with result of optimization transport network
        :param file_path: file path
        :return: None
        &#34;&#34;&#34;
        string_lines = self.string_network_results()
        file = open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;)
        file.write(string_lines)
        file.close()

    def get_overall_results(self) -&gt; defaultdict:
        &#34;&#34;&#34;
        to get overall cost results per passenger
        :return: defaultdict:

        Key [unit]: value type

        VRC [USD$/hr-pax]: float,
        operators_cost [USD$/hr-pax]: float,
        infrastructure_cost [USD$/hr-pax]: float,
        users_cost [USD$/hr-pax]: float,
        travel_time_on_board [min/pax]: float,
        waiting time [min/pax]: float,
        access_time [min/pax]: float,
        transfers [transfer/pax]: float,
        vehicles_mode [veh/mode]: dic[TransportMode] = float [veh],
        vehicle_capacity_mode [pax/veh]: dic[TransportMode] = float [pax/veh],
        lines_mode : dic[TransportMode]=int [lines])
        &#34;&#34;&#34;
        if self.better_res is not None:
            res = self.better_res
        else:
            raise NoOptimalSolutionFoundException(&#34;not solution found in optimizer object&#34;)

        fopt, success, status, message, constr_violation, vrc = res
        final_optimizer, z, v, k, loaded_section_route = self.last_iteration(res)

        f = self.fopt_to_f(fopt)

        # resultados de costos
        CO = self.operators_cost(z, v, f, k)
        CI = self.infrastructure_cost(f)
        CU = self.user_cost(final_optimizer.hyperpaths, final_optimizer.Vij, final_optimizer.assignment,
                            final_optimizer.successors, final_optimizer.extended_graph_obj, f, z, v)

        VRC = CO + CI + CU

        # resultados de usuarios
        ta, te, tv, t = UsersCost.resources_consumer(final_optimizer.hyperpaths, final_optimizer.Vij,
                                                     final_optimizer.assignment, final_optimizer.successors,
                                                     final_optimizer.extended_graph_obj,
                                                     final_optimizer.passenger_obj.va, f, z, v)

        # resultados de modos
        travel_time_line = OperatorsCost.lines_travel_time(final_optimizer.network_obj.get_routes(),
                                                           final_optimizer.graph_obj.get_edges_distance())
        cycle_time_line = OperatorsCost.get_cycle_time(z, v, final_optimizer.network_obj.get_routes(), travel_time_line)

        B = defaultdict(float)
        L = defaultdict(int)

        K_list = defaultdict(list)
        K = defaultdict(float)

        for route in self.network_obj.get_routes():
            if f[route.id] &gt; 0:
                B[route.mode] += f[route.id] * cycle_time_line[route.id]
                L[route.mode] += route.mode.d
                K_list[route.mode].append(k[route.id])

        for mode in K_list:
            l = K_list[mode]
            K[mode] = sum(l) / len(l)

        output = defaultdict(None)
        output[&#34;VRC&#34;] = VRC / self.total_trips
        output[&#34;operators_cost&#34;] = CO / self.total_trips
        output[&#34;infrastructure_cost&#34;] = CI / self.total_trips
        output[&#34;users_cost&#34;] = CU / self.total_trips
        output[&#34;travel_time_on_board&#34;] = tv / self.total_trips * 60
        output[&#34;waiting_time&#34;] = te / self.total_trips * 60
        output[&#34;access_time&#34;] = ta / self.total_trips * 60
        output[&#34;transfers&#34;] = t / self.total_trips
        output[&#34;vehicles_mode&#34;] = B
        output[&#34;vehicle_capacity_mode&#34;] = K
        output[&#34;lines_mode&#34;] = L
        return output

    def string_overall_results(self) -&gt; str:
        &#34;&#34;&#34;
        to get a string to print overall results in console

        Key [unit]: value type

        VRC [USD$/hr-pax]: float,
        operators_cost [USD$/hr-pax]: float,
        infrastructure_cost [USD$/hr-pax]: float,
        users_cost [USD$/hr-pax]: float,
        travel_time_on_board [min/pax]: float,
        waiting time [min/pax]: float,
        access_time [min/pax]: float,
        transfers [transfer/pax]: float,
        vehicles_mode [veh/mode]: dic[TransportMode] = float [veh],
        vehicle_capacity_mode [pax/veh]: dic[TransportMode] = float [pax/veh],
        lines_mode : dic[TransportMode]=int [lines])
        :return: string to print overall results in console
        &#34;&#34;&#34;
        overall_results = self.get_overall_results()

        vrc = overall_results[&#34;VRC&#34;]
        co = overall_results[&#34;operators_cost&#34;]
        ci = overall_results[&#34;infrastructure_cost&#34;]
        cu = overall_results[&#34;users_cost&#34;]
        tv = overall_results[&#34;travel_time_on_board&#34;]
        te = overall_results[&#34;waiting_time&#34;]
        ta = overall_results[&#34;access_time&#34;]
        t = overall_results[&#34;transfers&#34;]
        b = overall_results[&#34;vehicles_mode&#34;]
        k = overall_results[&#34;vehicle_capacity_mode&#34;]
        l = overall_results[&#34;lines_mode&#34;]

        line = &#34;\n\nObjective function VRC [USD$/hr-pax]: {:.2f}&#34;.format(vrc)
        line += &#34;\nOperators cost [USD$/hr-pax]        : {:.2f}&#34;.format(co)
        line += &#34;\nInfrastructure cost [USD$/hr-pax]   : {:.2f}&#34;.format(ci)
        line += &#34;\nUsers cost [USD$/hr-pax]            : {:.2f}&#34;.format(cu)

        line += &#34;\n\nResources consumer for users&#34;
        line += &#34;\nTime on board vehicle [min/pax]: {:.2f}&#34;.format(tv)
        line += &#34;\nWaiting time [min/pax]         : {:.2f}&#34;.format(te)
        line += &#34;\nAccess time [min/pax]          : {:.2f}&#34;.format(ta)
        line += &#34;\ntotal travel time [min/pax]    : {:.2f}&#34;.format(tv + ta + te)
        line += &#34;\nTransfers [transfers/pax]      : {:.2f}&#34;.format(t)

        line += &#34;\n\n&#34;
        line += &#34;Transport mode information: {}&#34;.format(len(b))

        for mode in b:
            line += &#34;\n\n\tMode name: {}&#34;.format(mode.name)
            line += &#34;\n\tB [veh]      : {:.2f}&#34;.format(b[mode])
            line += &#34;\n\tK [pax/veh]  : {:.2f}&#34;.format(k[mode])
            line += &#34;\n\tL [lines]    : {}&#34;.format(l[mode])

        return line</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sidermit.optimization.Optimizer.external_optimization"><code class="name flex">
<span>def <span class="ident">external_optimization</span></span>(<span>graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger, network_obj: TransportNetwork, f: defaultdict_float = None, tolerance: float = 0.01, number_of_iteration: int = None) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>method to do external optimization process, several iterations of internal optimization with fixed
hyperpaths in each
:param graph_obj: Graph object
:param demand_obj: Demand object
:param passenger_obj: Passenger object
:param network_obj: TransportNetwork object
:param f: dict with frequency [veh/hr] for each route_id, dic[route_id] = frequency
:param tolerance: float, tolerance to external optimization
:param number_of_iteration: int, max. number of iterations. Default value is infinity.
it is recommended to set this value in a small number of iterations (e.x. 5) in the beginning to know if it
converges
:return: (fopt, success, status, message, constr_violation, vrc)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def external_optimization(graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger,
                          network_obj: TransportNetwork,
                          f: defaultdict_float = None, tolerance: float = 0.01,
                          number_of_iteration: int = None) -&gt; Tuple:
    &#34;&#34;&#34;
    method to do external optimization process, several iterations of internal optimization with fixed
    hyperpaths in each
    :param graph_obj: Graph object
    :param demand_obj: Demand object
    :param passenger_obj: Passenger object
    :param network_obj: TransportNetwork object
    :param f: dict with frequency [veh/hr] for each route_id, dic[route_id] = frequency
    :param tolerance: float, tolerance to external optimization
    :param number_of_iteration: int, max. number of iterations. Default value is infinity.
    it is recommended to set this value in a small number of iterations (e.x. 5) in the beginning to know if it
    converges
    :return: (fopt, success, status, message, constr_violation, vrc)
    &#34;&#34;&#34;

    list_res = []

    opt_obj = Optimizer(graph_obj, demand_obj, passenger_obj, network_obj, f)
    # inicialización
    list_res.append((opt_obj.f_opt, &#34;initialization&#34;, -1, &#34;initialization&#34;, -1, -1))

    # primera iteracion
    res = opt_obj.internal_optimization()
    list_res.append((res.x, res.success, res.status, res.message, res.constr_violation, res.fun))

    pre_f, _, _, _, _, _ = list_res[0]
    new_f, _, _, _, _, _ = list_res[1]

    iteration = 1
    # mientras criterio de tolerancia externo no se cumpla o se llegue al maximo numero de iteraciones
    while not opt_obj.external_optimization_tolerance(pre_f, new_f, tolerance):
        if number_of_iteration is not None:
            if iteration &gt; number_of_iteration:
                break
        pre_f = new_f
        dic_new_f = opt_obj.fopt_to_f(new_f)
        opt_obj = Optimizer(graph_obj, demand_obj, passenger_obj, network_obj, dic_new_f)
        res = opt_obj.internal_optimization()
        list_res.append((res.x, res.success, res.status, res.message, res.constr_violation, res.fun))
        new_f = res.x
        iteration += 1

    better_result = opt_obj.get_better_result(list_res)

    if opt_obj.status_optimization(better_result):
        return better_result</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.f_distance"><code class="name flex">
<span>def <span class="ident">f_distance</span></span>(<span>prev_f: List[float], new_f: List[float]) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get distance between 2 list of frequency results.
:param prev_f: previous frequency
:param new_f: new frequency
:return: float, distance with normal distance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def f_distance(prev_f: List[float], new_f: List[float]) -&gt; float:
    &#34;&#34;&#34;
    to get distance between 2 list of frequency results.
    :param prev_f: previous frequency
    :param new_f: new frequency
    :return: float, distance with normal distance
    &#34;&#34;&#34;
    dif = 0
    for i in range(len(prev_f)):
        dif += abs(prev_f[i] - new_f[i])
    dif = dif  # ** (1 / len(prev_f))
    logger.info(&#34;f_norm_distance: {}&#34;.format(dif))
    return dif</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.get_better_result"><code class="name flex">
<span>def <span class="ident">get_better_result</span></span>(<span>list_res)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_better_result(list_res):
    valid_result = []
    for x, success, status, message, constr_violation, fun in list_res:
        if status not in [0, 3, -1] and abs(constr_violation) &lt; 0.001:
            cond_f = True
            for f in x:
                if f &lt; 0:
                    cond_f = False
                    break
            if cond_f:
                valid_result.append((x, success, status, message, constr_violation, fun))

    better_result = None
    max_fun = float(&#34;inf&#34;)
    for x, success, status, message, constr_violation, fun in valid_result:
        if fun &lt; max_fun:
            max_fun = fun
            better_result = (x, success, status, message, constr_violation, fun)

    return better_result</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.get_k"><code class="name flex">
<span>def <span class="ident">get_k</span></span>(<span>loaded_section_route: defaultdict3_float) ‑> defaultdict_float</span>
</code></dt>
<dd>
<div class="desc"><p>:param loaded_section_route: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:return: k: dic[route_id] = vehicle capacity [pax/veh]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_k(loaded_section_route: defaultdict3_float) -&gt; defaultdict_float:
    &#34;&#34;&#34;
    :param loaded_section_route: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :return: k: dic[route_id] = vehicle capacity [pax/veh]
    &#34;&#34;&#34;
    most_loaded_section = Assignment.most_loaded_section(loaded_section_route)
    k = defaultdict(float)
    for route_id in most_loaded_section:
        k[route_id] = most_loaded_section[route_id]
    return k</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.network_optimization"><code class="name flex">
<span>def <span class="ident">network_optimization</span></span>(<span>graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger, network_obj: TransportNetwork, f: defaultdict_float = None, tolerance: float = 0.01, max_number_of_iteration: int = None) ‑> <a title="sidermit.optimization.Optimizer" href="#sidermit.optimization.Optimizer">Optimizer</a></span>
</code></dt>
<dd>
<div class="desc"><p>obtain optimal frequency for the defined network if possible or raise exceptions in case of not being able
:param graph_obj: Graph object
:param demand_obj: Demand object
:param passenger_obj: Passenger object
:param network_obj: TransportNetwork object
:param f: dict with frequency [veh/hr] for each route_id, dic[route_id] = frequency, if f is None then fini of
each TransportMode defined in TransportNetwork define f.
:param tolerance: float, tolerance to external optimization
:param max_number_of_iteration: int, max. number of iterations. Default value is infinity.
it is recommended to set this value in a small number of iterations (e.x. 5) in the beginning to know if it
converges
:return: opt_obj</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def network_optimization(graph_obj: Graph, demand_obj: Demand, passenger_obj: Passenger,
                         network_obj: TransportNetwork,
                         f: defaultdict_float = None, tolerance: float = 0.01,
                         max_number_of_iteration: int = None) -&gt; Optimizer:
    &#34;&#34;&#34;
    obtain optimal frequency for the defined network if possible or raise exceptions in case of not being able
    :param graph_obj: Graph object
    :param demand_obj: Demand object
    :param passenger_obj: Passenger object
    :param network_obj: TransportNetwork object
    :param f: dict with frequency [veh/hr] for each route_id, dic[route_id] = frequency, if f is None then fini of
    each TransportMode defined in TransportNetwork define f.
    :param tolerance: float, tolerance to external optimization
    :param max_number_of_iteration: int, max. number of iterations. Default value is infinity.
    it is recommended to set this value in a small number of iterations (e.x. 5) in the beginning to know if it
    converges
    :return: opt_obj
    &#34;&#34;&#34;

    opt_obj = Optimizer(graph_obj, demand_obj, passenger_obj, network_obj, f)
    opt_obj.better_res = opt_obj.external_optimization(graph_obj, demand_obj, passenger_obj, network_obj, f,
                                                       tolerance, number_of_iteration=max_number_of_iteration)

    logger.info(opt_obj.string_network_optimization(opt_obj.better_res))

    return opt_obj</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.status_optimization"><code class="name flex">
<span>def <span class="ident">status_optimization</span></span>(<span>better_res) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>to get a information about status of external optimization
:param better_res:(fopt, success, status, message, constr_violation, vrc)
:return: true if status is success, exceptions if not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def status_optimization(better_res) -&gt; bool:
    &#34;&#34;&#34;
    to get a information about status of external optimization
    :param better_res:(fopt, success, status, message, constr_violation, vrc)
    :return: true if status is success, exceptions if not
    &#34;&#34;&#34;

    if better_res is None:
        raise NoOptimalSolutionFoundException(
            &#34;No optimal solution was found. You can try with other fini or total demand is very large for the proposed network.&#34;)

    fopt, success, status, message, constr_violation, fun = better_res

    for f in fopt:
        if f &lt; -0.1:
            raise NegativeFrequencyException(&#34;Solution with negative frequency. You can try with other fini&#34;)

    if abs(constr_violation) &gt; 0.1:
        raise ConstraintViolationException(
            &#34;Maximum constraint violation at the solution {}. You can try with other fini or total demand is very large for the proposed network.&#34;.format(
                constr_violation))

    if status == 0 or status == 3:
        raise NoOptimalSolutionFoundException(
            &#34;No optimal solution was found. You can try with other fini or total demand is very large for the proposed network.&#34;)

    return True</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.string_information_internal_optimization"><code class="name flex">
<span>def <span class="ident">string_information_internal_optimization</span></span>(<span>res: OptimizeResult) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>to get a string with information about internal optimization
:param res: OptimizeResult
:return: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def string_information_internal_optimization(res: OptimizeResult) -&gt; str:
    &#34;&#34;&#34;
    to get a string with information about internal optimization
    :param res: OptimizeResult
    :return: str
    &#34;&#34;&#34;

    success = res.success
    status = res.status
    message = res.message
    new_f = res.x
    constr_violation = res.constr_violation
    fun = res.fun

    line = &#34;Internal optimization\n\tSuccess: {}\n\tStatus: {}\n\tMessage: {}\n\tnew_f: {}\n\tConstrain violation: {}\n\tVRC: {}&#34;.format(
        success, status, message, new_f, constr_violation, fun)
    return line</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sidermit.optimization.Optimizer.VRC"><code class="name flex">
<span>def <span class="ident">VRC</span></span>(<span>self, fopt: List[float]) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get VRC objective function to minime in optimizer
:param fopt: variable to optimize
:return: float, VRC value function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def VRC(self, fopt: List[float]) -&gt; float:
    &#34;&#34;&#34;
    to get VRC objective function to minime in optimizer
    :param fopt: variable to optimize
    :return: float, VRC value function
    &#34;&#34;&#34;

    f = self.fopt_to_f(fopt)

    z, v, loaded_section_route = Assignment.get_alighting_and_boarding(self.Vij, self.hyperpaths, self.successors,
                                                                       self.assignment, f)
    k = self.get_k(loaded_section_route)

    CO = self.operators_cost(z, v, f, k)
    CI = self.infrastructure_cost(f)
    CU = self.user_cost(self.hyperpaths, self.Vij, self.assignment, self.successors, self.extended_graph_obj, f, z,
                        v)

    return CO + CI + CU</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.constrains"><code class="name flex">
<span>def <span class="ident">constrains</span></span>(<span>self, loaded_section_route: defaultdict3_float, f: defaultdict_float) ‑> (List[float], List[float])</span>
</code></dt>
<dd>
<div class="desc"><p>to get k constrains and f constrains
:param loaded_section_route: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param f: dict with frequency [veh/hr] for each route_id
:return: (k_ineq_constrains, f_ineq_constrains)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def constrains(self, loaded_section_route: defaultdict3_float, f: defaultdict_float) -&gt; (
        List[float], List[float]):
    &#34;&#34;&#34;
    to get k constrains and f constrains
    :param loaded_section_route: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param f: dict with frequency [veh/hr] for each route_id
    :return: (k_ineq_constrains, f_ineq_constrains)
    &#34;&#34;&#34;

    most_loaded_section = Assignment.most_loaded_section(loaded_section_route)

    constrains_obj = Constrains()

    ineq_k = constrains_obj.most_loaded_section_constrains(self.network_obj.get_routes(), most_loaded_section)
    ineq_f = constrains_obj.fmax_constrains(self.graph_obj, self.network_obj.get_routes(),
                                            self.network_obj.get_modes(), f)

    return ineq_k, ineq_f</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.external_optimization_tolerance"><code class="name flex">
<span>def <span class="ident">external_optimization_tolerance</span></span>(<span>self, prev_f: List[float], new_f: List[float], tol: float = 0.01) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>True, if tolerance criteria is success
:param prev_f: previous frequency
:param new_f: new frequency
:param tol: float, tolerance
:return: True, if tolerance criteria is success</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def external_optimization_tolerance(self, prev_f: List[float], new_f: List[float], tol: float = 0.01) -&gt; bool:
    &#34;&#34;&#34;
    True, if tolerance criteria is success
    :param prev_f: previous frequency
    :param new_f: new frequency
    :param tol: float, tolerance
    :return: True, if tolerance criteria is success
    &#34;&#34;&#34;

    if tol &gt; abs(self.f_distance(prev_f, new_f)):
        return True

    return False</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.f0"><code class="name flex">
<span>def <span class="ident">f0</span></span>(<span>self, f: defaultdict_float = None) ‑> (defaultdict_float, List[float], defaultdict_str)</span>
</code></dt>
<dd>
<div class="desc"><p>to get a relation between f as a dictionary and f_opt as a list to the optimizer
:param f: dic[route_id] = frequency [veh/hr] for all D lines
:return: dic[route_id] = frequency [veh/hr] for all D lines, List[frequency], dic[position] = route_id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def f0(self, f: defaultdict_float = None) -&gt; (defaultdict_float, List[float], defaultdict_str):
    &#34;&#34;&#34;
    to get a relation between f as a dictionary and f_opt as a list to the optimizer
    :param f: dic[route_id] = frequency [veh/hr] for all D lines
    :return: dic[route_id] = frequency [veh/hr] for all D lines, List[frequency], dic[position] = route_id
    &#34;&#34;&#34;
    fini = defaultdict(float)
    fopt = []
    lines_position = defaultdict(None)
    n = 0
    if f is None:
        for route in self.network_obj.get_routes():
            fini[route.id] = route.mode.fini
            fopt.append(route.mode.fini)
            lines_position[n] = route.id
            n += 1
    else:
        for route in self.network_obj.get_routes():
            fini[route.id] = f[route.id]
            fopt.append(route.mode.fini)
            lines_position[n] = route.id
            n += 1

    return fini, fopt, lines_position</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.fopt_to_f"><code class="name flex">
<span>def <span class="ident">fopt_to_f</span></span>(<span>self, fopt: List[float]) ‑> defaultdict_float</span>
</code></dt>
<dd>
<div class="desc"><p>to get f as a dictionary
:param fopt: List[frequency]
:return: dic[route_id] = frequency [veh/hr] all D lines</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fopt_to_f(self, fopt: List[float]) -&gt; defaultdict_float:
    &#34;&#34;&#34;
    to get f as a dictionary
    :param fopt: List[frequency]
    :return: dic[route_id] = frequency [veh/hr] all D lines
    &#34;&#34;&#34;
    f = defaultdict(float)
    n = 0
    for fr in fopt:
        f[self.lines_position[n]] = fr
        n += 1
    return f</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.get_constrains"><code class="name flex">
<span>def <span class="ident">get_constrains</span></span>(<span>self, fopt: List[float]) ‑> List[float]</span>
</code></dt>
<dd>
<div class="desc"><p>to get all constrains as a List[float]
:param fopt: variable to optimize
:return: all constrains as a List[float]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_constrains(self, fopt: List[float]) -&gt; List[float]:
    &#34;&#34;&#34;
    to get all constrains as a List[float]
    :param fopt: variable to optimize
    :return: all constrains as a List[float]
    &#34;&#34;&#34;

    f = self.fopt_to_f(fopt)

    z, v, loaded_section_route = Assignment.get_alighting_and_boarding(self.Vij, self.hyperpaths, self.successors,
                                                                       self.assignment, f)

    most_loaded_section = Assignment.most_loaded_section(loaded_section_route)
    constrain_obj = Constrains()
    ineq_k = constrain_obj.most_loaded_section_constrains(self.network_obj.get_routes(), most_loaded_section)
    ineq_f = constrain_obj.fmax_constrains(self.graph_obj, self.network_obj.get_routes(),
                                           self.network_obj.get_modes(), f)

    con = []
    for c in ineq_k:
        con.append(c)
    for c in ineq_f:
        con.append(c)

    return con</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.get_network_results"><code class="name flex">
<span>def <span class="ident">get_network_results</span></span>(<span>self) ‑> List[Tuple]</span>
</code></dt>
<dd>
<div class="desc"><p>to get transport network results per line-direction
:return: List[(route.id: str, f [veh/hr]: float, k [pax/veh]: float, B [veh]: float, cycle_time [hr]: float,
CO [US$/hr-pax]: float, lambda_min, sub_table_i: List[(node_i, node_j, lambda)],
sub_table_i: List[(node_i, node_j, lambda)]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_network_results(self) -&gt; List[Tuple]:
    &#34;&#34;&#34;
    to get transport network results per line-direction
    :return: List[(route.id: str, f [veh/hr]: float, k [pax/veh]: float, B [veh]: float, cycle_time [hr]: float,
    CO [US$/hr-pax]: float, lambda_min, sub_table_i: List[(node_i, node_j, lambda)],
    sub_table_i: List[(node_i, node_j, lambda)]
    &#34;&#34;&#34;
    if self.better_res is not None:
        res = self.better_res
    else:
        raise NoOptimalSolutionFoundException(&#34;not solution found in optimizer object&#34;)

    output = []

    fopt, success, status, message, constr_violation, vrc = res
    final_optimizer, z, v, k, loaded_section_route = self.last_iteration(res)

    f = self.fopt_to_f(fopt)

    # resultados de modos
    travel_time_line = OperatorsCost.lines_travel_time(final_optimizer.network_obj.get_routes(),
                                                       final_optimizer.graph_obj.get_edges_distance())
    cycle_time_line = OperatorsCost.get_cycle_time(z, v, final_optimizer.network_obj.get_routes(), travel_time_line)

    for route in final_optimizer.network_obj.get_routes():

        # flota de buses
        b = cycle_time_line[route.id] * f[route.id]
        nodes_sequence_i = route.nodes_sequence_i
        nodes_sequence_r = route.nodes_sequence_r
        # carga que hay en los tramos
        total_pax = 0
        charge_i = []
        charge_r = []
        # total de subidas a la ruta
        total_b = 0

        # caso circular
        if route._type == RouteType.CIRCULAR:

            # circular con sentido de ida
            if len(nodes_sequence_i) &gt; 0:
                node_sequence = nodes_sequence_i
                direction = &#34;I&#34;
            # circular con sentido de vuelta
            else:
                node_sequence = nodes_sequence_r
                direction = &#34;R&#34;
            load_i = []
            for i in node_sequence:
                for stop_node in z[route.id][direction]:
                    if stop_node.city_node.graph_node.id == i:
                        total_b += z[route.id][direction][stop_node]
                        break
                for stop_node in loaded_section_route[route.id][direction]:
                    if stop_node.city_node.graph_node.id == i:
                        load_i.append(loaded_section_route[route.id][direction][stop_node])
                        break

            if total_b == 0:
                co = 0
            else:
                co = (route.mode.co + route.mode.c1 * k[route.id]) * f[route.id] * cycle_time_line[route.id] / (
                        total_b * f[route.id])

            if len(load_i) &gt;= 1:
                charge_min = min(load_i) / max(load_i)
            else:
                load_i = [1] * len(node_sequence)
                charge_min = 0

            sub_table = []
            sub_table_i = []
            sub_table_r = []

            node_i = None
            charge_ij = None
            for i in range(len(node_sequence)):
                if i == 0:
                    node_i = node_sequence[i]
                    charge_ij = load_i[i] / max(load_i)
                    continue
                else:
                    node_j = node_sequence[i]
                    sub_table.append((node_i, node_j, abs(charge_ij)))
                    node_i = node_j
                    charge_ij = load_i[i] / max(load_i)

            # circular con sentido de ida
            if len(nodes_sequence_i) &gt; 0:
                sub_table_i = sub_table
            # circular con sentido de vuelta
            else:
                sub_table_r = sub_table

            output.append((
                route.id, f[route.id], f[route.id] / route.mode.d, k[route.id], b, cycle_time_line[route.id] * 60,
                co, abs(charge_min), sub_table_i, sub_table_r))
        else:
            # z and v: dic[route_id][direction][stop: StopNode] = pax [pax/veh]
            total_pax = 0
            for node_id in nodes_sequence_i:
                bool_add = False
                for stopnode in z[route.id][&#34;I&#34;]:
                    if stopnode.city_node.graph_node.id == node_id:
                        pax_b = z[route.id][&#34;I&#34;][stopnode]
                        pax_a = v[route.id][&#34;I&#34;][stopnode]
                        total_pax += pax_b - pax_a
                        total_b += pax_b

                        charge_i.append((node_id, total_pax / k[route.id]))
                        bool_add = True
                        break
                if bool_add is False:
                    charge_i.append((node_id, total_pax / k[route.id]))

            total_pax = 0
            for node_id in nodes_sequence_r:
                bool_add = False
                for stopnode in z[route.id][&#34;R&#34;]:
                    if stopnode.city_node.graph_node.id == node_id:
                        pax_b = z[route.id][&#34;R&#34;][stopnode]
                        pax_a = v[route.id][&#34;R&#34;][stopnode]
                        total_pax += pax_b - pax_a
                        total_b += pax_b

                        charge_r.append((node_id, total_pax / k[route.id]))
                        bool_add = True
                        break
                if bool_add is False:
                    charge_r.append((node_id, total_pax / k[route.id]))

            co = (route.mode.co + route.mode.c1 * k[route.id]) * f[route.id] * cycle_time_line[route.id] / (
                    total_b * f[route.id])

            charge_min = float(&#34;inf&#34;)
            sub_table_i = []
            node_i = None
            charge_ij = None
            for node_j, charge in charge_i:
                if node_i is None:
                    node_i = node_j
                    charge_ij = charge
                    continue
                else:
                    sub_table_i.append((node_i, node_j, abs(charge_ij)))
                    if charge_min &gt; charge_ij:
                        charge_min = charge_ij
                    node_i = node_j
                    charge_ij = charge

            sub_table_r = []
            node_i = None
            charge_ij = None
            for node_j, charge in charge_r:
                if node_i is None:
                    node_i = node_j
                    charge_ij = charge
                    continue
                else:
                    sub_table_r.append((node_i, node_j, abs(charge_ij)))
                    if charge_min &gt; charge_ij:
                        charge_min = charge_ij
                    node_i = node_j
                    charge_ij = charge

            output.append((
                route.id, f[route.id], f[route.id] / route.mode.d, k[route.id], b, cycle_time_line[route.id] * 60,
                co, abs(charge_min), sub_table_i, sub_table_r))

    return output</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.get_optimization_value"><code class="name flex">
<span>def <span class="ident">get_optimization_value</span></span>(<span>self) ‑> Tuple</span>
</code></dt>
<dd>
<div class="desc"><p>to get optimization value saved
:return: (fopt, success, status, message, constr_violation, vrc)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_optimization_value(self) -&gt; Tuple:
    &#34;&#34;&#34;
    to get optimization value saved
    :return: (fopt, success, status, message, constr_violation, vrc)
    &#34;&#34;&#34;
    return self.better_res</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.get_overall_results"><code class="name flex">
<span>def <span class="ident">get_overall_results</span></span>(<span>self) ‑> collections.defaultdict</span>
</code></dt>
<dd>
<div class="desc"><p>to get overall cost results per passenger
:return: defaultdict:</p>
<p>Key [unit]: value type</p>
<p>VRC [USD$/hr-pax]: float,
operators_cost [USD$/hr-pax]: float,
infrastructure_cost [USD$/hr-pax]: float,
users_cost [USD$/hr-pax]: float,
travel_time_on_board [min/pax]: float,
waiting time [min/pax]: float,
access_time [min/pax]: float,
transfers [transfer/pax]: float,
vehicles_mode [veh/mode]: dic[TransportMode] = float [veh],
vehicle_capacity_mode [pax/veh]: dic[TransportMode] = float [pax/veh],
lines_mode : dic[TransportMode]=int [lines])</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_overall_results(self) -&gt; defaultdict:
    &#34;&#34;&#34;
    to get overall cost results per passenger
    :return: defaultdict:

    Key [unit]: value type

    VRC [USD$/hr-pax]: float,
    operators_cost [USD$/hr-pax]: float,
    infrastructure_cost [USD$/hr-pax]: float,
    users_cost [USD$/hr-pax]: float,
    travel_time_on_board [min/pax]: float,
    waiting time [min/pax]: float,
    access_time [min/pax]: float,
    transfers [transfer/pax]: float,
    vehicles_mode [veh/mode]: dic[TransportMode] = float [veh],
    vehicle_capacity_mode [pax/veh]: dic[TransportMode] = float [pax/veh],
    lines_mode : dic[TransportMode]=int [lines])
    &#34;&#34;&#34;
    if self.better_res is not None:
        res = self.better_res
    else:
        raise NoOptimalSolutionFoundException(&#34;not solution found in optimizer object&#34;)

    fopt, success, status, message, constr_violation, vrc = res
    final_optimizer, z, v, k, loaded_section_route = self.last_iteration(res)

    f = self.fopt_to_f(fopt)

    # resultados de costos
    CO = self.operators_cost(z, v, f, k)
    CI = self.infrastructure_cost(f)
    CU = self.user_cost(final_optimizer.hyperpaths, final_optimizer.Vij, final_optimizer.assignment,
                        final_optimizer.successors, final_optimizer.extended_graph_obj, f, z, v)

    VRC = CO + CI + CU

    # resultados de usuarios
    ta, te, tv, t = UsersCost.resources_consumer(final_optimizer.hyperpaths, final_optimizer.Vij,
                                                 final_optimizer.assignment, final_optimizer.successors,
                                                 final_optimizer.extended_graph_obj,
                                                 final_optimizer.passenger_obj.va, f, z, v)

    # resultados de modos
    travel_time_line = OperatorsCost.lines_travel_time(final_optimizer.network_obj.get_routes(),
                                                       final_optimizer.graph_obj.get_edges_distance())
    cycle_time_line = OperatorsCost.get_cycle_time(z, v, final_optimizer.network_obj.get_routes(), travel_time_line)

    B = defaultdict(float)
    L = defaultdict(int)

    K_list = defaultdict(list)
    K = defaultdict(float)

    for route in self.network_obj.get_routes():
        if f[route.id] &gt; 0:
            B[route.mode] += f[route.id] * cycle_time_line[route.id]
            L[route.mode] += route.mode.d
            K_list[route.mode].append(k[route.id])

    for mode in K_list:
        l = K_list[mode]
        K[mode] = sum(l) / len(l)

    output = defaultdict(None)
    output[&#34;VRC&#34;] = VRC / self.total_trips
    output[&#34;operators_cost&#34;] = CO / self.total_trips
    output[&#34;infrastructure_cost&#34;] = CI / self.total_trips
    output[&#34;users_cost&#34;] = CU / self.total_trips
    output[&#34;travel_time_on_board&#34;] = tv / self.total_trips * 60
    output[&#34;waiting_time&#34;] = te / self.total_trips * 60
    output[&#34;access_time&#34;] = ta / self.total_trips * 60
    output[&#34;transfers&#34;] = t / self.total_trips
    output[&#34;vehicles_mode&#34;] = B
    output[&#34;vehicle_capacity_mode&#34;] = K
    output[&#34;lines_mode&#34;] = L
    return output</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.infrastructure_cost"><code class="name flex">
<span>def <span class="ident">infrastructure_cost</span></span>(<span>self, f: defaultdict_float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get infrastructure cost
:param f: dic[route_id] = frequency [veh/hr]
:return: float, infrastructure cost</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def infrastructure_cost(self, f: defaultdict_float) -&gt; float:
    &#34;&#34;&#34;
    to get infrastructure cost
    :param f: dic[route_id] = frequency [veh/hr]
    :return: float, infrastructure cost
    &#34;&#34;&#34;
    infrastructure_cost_obj = InfrastructureCost()
    cost = infrastructure_cost_obj.get_infrastruture_cost(self.graph_obj, self.network_obj, f)
    return cost</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.internal_optimization"><code class="name flex">
<span>def <span class="ident">internal_optimization</span></span>(<span>self) ‑> scipy.optimize.optimize.OptimizeResult</span>
</code></dt>
<dd>
<div class="desc"><p>method to do internal optimization process, with a hyperpath setted you can get a optimization of the network
:return:
res : OptimizeResult
The optimization result represented as a <code>OptimizeResult</code> object.
Important attributes are: <code>x</code> the solution array, <code>success</code> a
Boolean flag indicating if the optimizer exited successfully and
<code>message</code> which describes the cause of the termination. See
<code>OptimizeResult</code> for a description of other attributes.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def internal_optimization(self) -&gt; OptimizeResult:
    &#34;&#34;&#34;
    method to do internal optimization process, with a hyperpath setted you can get a optimization of the network
    :return:     res : OptimizeResult
    The optimization result represented as a ``OptimizeResult`` object.
    Important attributes are: ``x`` the solution array, ``success`` a
    Boolean flag indicating if the optimizer exited successfully and
    ``message`` which describes the cause of the termination. See
    `OptimizeResult` for a description of other attributes.
    &#34;&#34;&#34;

    constr_func = lambda fopt: np.array(self.get_constrains(fopt))

    lb = [-1 * np.inf] * self.len_constrains
    ub = [0] * self.len_constrains
    nonlin_con = NonlinearConstraint(constr_func, lb=lb, ub=ub)

    lb = [0] * self.len_var
    ub = [np.inf] * self.len_var

    bounds = Bounds(lb=lb, ub=ub)
    res = minimize(self.VRC, self.f_opt, method=&#39;trust-constr&#39;, constraints=nonlin_con, tol=0.01, bounds=bounds)
    logger.info(self.string_information_internal_optimization(res))

    return res</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.last_iteration"><code class="name flex">
<span>def <span class="ident">last_iteration</span></span>(<span>self, res: Tuple)</span>
</code></dt>
<dd>
<div class="desc"><p>return last network optimized with optimization result
:param res: res: Tuple, (fopt, success, status, message, constr_violation, vrc)
:return: Optimizer object, boarding dictionary, alighting dictionary, k dictionary, loaded_section_route</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def last_iteration(self, res: Tuple):
    &#34;&#34;&#34;
    return last network optimized with optimization result
    :param res: res: Tuple, (fopt, success, status, message, constr_violation, vrc)
    :return: Optimizer object, boarding dictionary, alighting dictionary, k dictionary, loaded_section_route
    &#34;&#34;&#34;
    fopt, success, status, message, constr_violation, vrc = res
    f = self.fopt_to_f(fopt)
    final_optimizer = Optimizer(self.graph_obj, self.demand_obj, self.passenger_obj, self.network_obj, f)
    z, v, loaded_section_route = Assignment.get_alighting_and_boarding(final_optimizer.Vij,
                                                                       final_optimizer.hyperpaths,
                                                                       final_optimizer.successors,
                                                                       final_optimizer.assignment, f)
    k = self.get_k(loaded_section_route)
    return final_optimizer, z, v, k, loaded_section_route</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.operators_cost"><code class="name flex">
<span>def <span class="ident">operators_cost</span></span>(<span>self, z: defaultdict3_float, v: defaultdict3_float, f: defaultdict_float, k: defaultdict_float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get operators cost
:param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param f: dic[route_id] = frequency [veh/hr]
:param k: dic[route_id] = frequency [pax/veh]
:return: float, operator cost</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def operators_cost(self, z: defaultdict3_float, v: defaultdict3_float, f: defaultdict_float,
                   k: defaultdict_float) -&gt; float:
    &#34;&#34;&#34;
    to get operators cost
    :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param f: dic[route_id] = frequency [veh/hr]
    :param k: dic[route_id] = frequency [pax/veh]
    :return: float, operator cost
    &#34;&#34;&#34;
    operators_cost_obj = OperatorsCost()

    edge_distance = self.graph_obj.get_edges_distance()
    routes = self.network_obj.get_routes()
    line_travel_time = operators_cost_obj.lines_travel_time(routes, edge_distance)

    cycle_time = operators_cost_obj.get_cycle_time(z, v, routes, line_travel_time)
    cost = operators_cost_obj.get_operators_cost(routes, cycle_time, f, k)
    return cost</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.string_network_optimization"><code class="name flex">
<span>def <span class="ident">string_network_optimization</span></span>(<span>self, res: Tuple) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>get a str summary about last external optimization in network_optimization
:param res: Tuple, (fopt, success, status, message, constr_violation, vrc)
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_network_optimization(self, res: Tuple) -&gt; str:
    &#34;&#34;&#34;
    get a str summary about last external optimization in network_optimization
    :param res: Tuple, (fopt, success, status, message, constr_violation, vrc)
    :return:
    &#34;&#34;&#34;
    fopt, success, status, message, constr_violation, vrc = res
    f = self.fopt_to_f(fopt)

    line = &#34;\n\nOptimization Results&#34;
    line += &#34;\nSuccess: {}&#34;.format(success)
    line += &#34;\nStatus: {}&#34;.format(status)
    line += &#34;\nMessage: {}&#34;.format(message)
    line += &#34;\nMax constrain violation: {}&#34;.format(constr_violation)
    line += &#34;\nVRC: {}&#34;.format(vrc)
    line += &#34;\n\nFrequency information [veh/hr]: &#34;
    for route_id in f:
        line += &#34;\n\t{}: {:.2f}&#34;.format(route_id, f[route_id])

    return line</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.string_network_results"><code class="name flex">
<span>def <span class="ident">string_network_results</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>to get a string with network results
:return: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_network_results(self) -&gt; str:
    &#34;&#34;&#34;
    to get a string with network results
    :return: str
    &#34;&#34;&#34;

    output_network_results = self.get_network_results()
    line = &#34;route_id;F[veh/hr];f[veh/hr-line];k[pax/veh];B[veh];tc[min];CO[US$/hr-pax];load_min;sub_table_i;sub_table_r&#34;

    for route_id, F, f, k, b, cycle_time, co, charge_min, sub_table_i, sub_table_r in output_network_results:
        line += &#34;\n{};{:.2f};{:.2f};{:.2f};{:.2f};{:.2f};{:.2f};{:.2f};{};{}&#34;.format(route_id, F, f, k, b,
                                                                                     cycle_time, co,
                                                                                     charge_min, sub_table_i,
                                                                                     sub_table_r)
    return line</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.string_overall_results"><code class="name flex">
<span>def <span class="ident">string_overall_results</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>to get a string to print overall results in console</p>
<p>Key [unit]: value type</p>
<p>VRC [USD$/hr-pax]: float,
operators_cost [USD$/hr-pax]: float,
infrastructure_cost [USD$/hr-pax]: float,
users_cost [USD$/hr-pax]: float,
travel_time_on_board [min/pax]: float,
waiting time [min/pax]: float,
access_time [min/pax]: float,
transfers [transfer/pax]: float,
vehicles_mode [veh/mode]: dic[TransportMode] = float [veh],
vehicle_capacity_mode [pax/veh]: dic[TransportMode] = float [pax/veh],
lines_mode : dic[TransportMode]=int [lines])
:return: string to print overall results in console</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def string_overall_results(self) -&gt; str:
    &#34;&#34;&#34;
    to get a string to print overall results in console

    Key [unit]: value type

    VRC [USD$/hr-pax]: float,
    operators_cost [USD$/hr-pax]: float,
    infrastructure_cost [USD$/hr-pax]: float,
    users_cost [USD$/hr-pax]: float,
    travel_time_on_board [min/pax]: float,
    waiting time [min/pax]: float,
    access_time [min/pax]: float,
    transfers [transfer/pax]: float,
    vehicles_mode [veh/mode]: dic[TransportMode] = float [veh],
    vehicle_capacity_mode [pax/veh]: dic[TransportMode] = float [pax/veh],
    lines_mode : dic[TransportMode]=int [lines])
    :return: string to print overall results in console
    &#34;&#34;&#34;
    overall_results = self.get_overall_results()

    vrc = overall_results[&#34;VRC&#34;]
    co = overall_results[&#34;operators_cost&#34;]
    ci = overall_results[&#34;infrastructure_cost&#34;]
    cu = overall_results[&#34;users_cost&#34;]
    tv = overall_results[&#34;travel_time_on_board&#34;]
    te = overall_results[&#34;waiting_time&#34;]
    ta = overall_results[&#34;access_time&#34;]
    t = overall_results[&#34;transfers&#34;]
    b = overall_results[&#34;vehicles_mode&#34;]
    k = overall_results[&#34;vehicle_capacity_mode&#34;]
    l = overall_results[&#34;lines_mode&#34;]

    line = &#34;\n\nObjective function VRC [USD$/hr-pax]: {:.2f}&#34;.format(vrc)
    line += &#34;\nOperators cost [USD$/hr-pax]        : {:.2f}&#34;.format(co)
    line += &#34;\nInfrastructure cost [USD$/hr-pax]   : {:.2f}&#34;.format(ci)
    line += &#34;\nUsers cost [USD$/hr-pax]            : {:.2f}&#34;.format(cu)

    line += &#34;\n\nResources consumer for users&#34;
    line += &#34;\nTime on board vehicle [min/pax]: {:.2f}&#34;.format(tv)
    line += &#34;\nWaiting time [min/pax]         : {:.2f}&#34;.format(te)
    line += &#34;\nAccess time [min/pax]          : {:.2f}&#34;.format(ta)
    line += &#34;\ntotal travel time [min/pax]    : {:.2f}&#34;.format(tv + ta + te)
    line += &#34;\nTransfers [transfers/pax]      : {:.2f}&#34;.format(t)

    line += &#34;\n\n&#34;
    line += &#34;Transport mode information: {}&#34;.format(len(b))

    for mode in b:
        line += &#34;\n\n\tMode name: {}&#34;.format(mode.name)
        line += &#34;\n\tB [veh]      : {:.2f}&#34;.format(b[mode])
        line += &#34;\n\tK [pax/veh]  : {:.2f}&#34;.format(k[mode])
        line += &#34;\n\tL [lines]    : {}&#34;.format(l[mode])

    return line</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.user_cost"><code class="name flex">
<span>def <span class="ident">user_cost</span></span>(<span>self, hyperpaths: dic_hyperpaths, Vij: dic_Vij, assignment: dic_assigment, successors: dic_successors, extended_graph: ExtendedGraph, f: defaultdict_float, z: defaultdict3_float, v: defaultdict3_float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get users cost
:param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
:param Vij: dic[origin: CityNode][destination: CityNode] = vij
:param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
:param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
:param extended_graph: ExtendedGraph object
:param f: dict with frequency [veh/hr] for each route_id
:param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:return: float, users cost</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def user_cost(self, hyperpaths: dic_hyperpaths, Vij: dic_Vij, assignment: dic_assigment,
              successors: dic_successors, extended_graph: ExtendedGraph, f: defaultdict_float,
              z: defaultdict3_float, v: defaultdict3_float) -&gt; float:
    &#34;&#34;&#34;
    to get users cost
    :param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
    :param Vij: dic[origin: CityNode][destination: CityNode] = vij
    :param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
    :param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
    :param extended_graph: ExtendedGraph object
    :param f: dict with frequency [veh/hr] for each route_id
    :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :return: float, users cost
    &#34;&#34;&#34;
    user_cost_obj = UsersCost()
    cost = user_cost_obj.get_users_cost(hyperpaths, Vij, assignment, successors, extended_graph, f,
                                        self.passenger_obj, z, v)
    return cost</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.Optimizer.write_file_network_results"><code class="name flex">
<span>def <span class="ident">write_file_network_results</span></span>(<span>self, file_path) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>to write output file with result of optimization transport network
:param file_path: file path
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def write_file_network_results(self, file_path) -&gt; None:
    &#34;&#34;&#34;
    to write output file with result of optimization transport network
    :param file_path: file path
    :return: None
    &#34;&#34;&#34;
    string_lines = self.string_network_results()
    file = open(file_path, &#39;w&#39;, encoding=&#39;utf-8&#39;)
    file.write(string_lines)
    file.close()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sidermit.optimization.UsersCost"><code class="flex name class">
<span>class <span class="ident">UsersCost</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class UsersCost:

    @staticmethod
    def resources_consumer(hyperpaths: dic_hyperpaths, Vij: dic_Vij, assignment: dic_assigment,
                           successors: dic_successors, extended_graph: ExtendedGraph, vp: float, f: defaultdict_float,
                           z: defaultdict2_float, v: defaultdict3_float) -&gt; (float, float, float, int):
        &#34;&#34;&#34;
        to get resources consumer for all passenger in transport network access time, waiting time,
        time on board of vehicle, numbers of transfer
        :param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
        :param Vij: dic[origin: CityNode][destination: CityNode] = vij
        :param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
        :param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
        :param extended_graph: ExtendedGraph object
        :param vp: passenger velocity [km/hr]
        :param f: dict with frequency [veh/hr] for each route_id
        :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :return: (access time, waiting time, time on boad, numbers of transfers): (float, float, float, int)
        &#34;&#34;&#34;
        ta = 0
        tv = 0
        te = 0
        t = 0

        edges = extended_graph.get_extended_graph_edges()

        for origin in hyperpaths:
            for destination in hyperpaths[origin]:
                # viajes del par OD
                vod = Vij[origin][destination]
                for stop in hyperpaths[origin][destination]:
                    # viajes de todas las rutas elementales que salen de esta parada
                    vod_s = vod * assignment[origin][destination][stop] / 100

                    if vod_s == 0:
                        continue

                    paths = []

                    for suc in successors[origin][destination][stop]:
                        nodej = suc.nodej
                        paths.append((stop, nodej, vod_s))

                    # reportar ta inicial (lateral y tecnologico)
                    ta += vod_s * (stop.mode.tat / 60 + assignment[origin][destination][
                        stop] / 100 * origin.graph_node.width / (4 * vp * stop.mode.d))

                    while len(paths) != 0:
                        nodei, nodej, pax = paths.pop(0)

                        # evita continuar si llegaste a destino
                        if isinstance(nodei, StopNode) and nodei.city_node == destination:
                            continue

                        dis_pax = pax

                        # reportar te
                        if isinstance(nodei, StopNode):
                            if isinstance(nodej, RouteNode):

                                f_acum = 0

                                for suc in successors[origin][destination][nodei]:
                                    f_acum += f[suc.nodej.route.id]

                                dis_pax = dis_pax * (f[nodej.route.id] / f_acum)

                                te += dis_pax * nodei.mode.theta / (f_acum / nodej.route.mode.d)

                        # reportar tv
                        if isinstance(nodei, RouteNode):
                            if isinstance(nodej, RouteNode):
                                for edge in edges:
                                    if edge.nodei == nodei and edge.nodej == nodej:
                                        tv += dis_pax * edge.t
                                        break

                        # reportar transbordos y tv de bajada
                        if isinstance(nodei, RouteNode):
                            if isinstance(nodej, StopNode):
                                # transbordos
                                if nodej.city_node != destination:
                                    t += dis_pax

                                # para tiempo de viaje adicional por esperar la bajada del vehiculo
                                nodei_id = nodei.prev_route_node.stop_node.city_node.graph_node.id
                                nodej_id = nodei.stop_node.city_node.graph_node.id

                                stop_sequence_i = nodei.route.stops_sequence_i

                                index = 0
                                index_i = 0
                                index_j = 0

                                for node_id in stop_sequence_i:
                                    if str(node_id) == str(nodei_id):
                                        index_i = index
                                    if str(node_id) == str(nodej_id):
                                        index_j = index
                                    index = index + 1

                                tb = nodei.route.mode.t / 3600
                                # verificamos si es del sentido de ida
                                if index_i &lt; index_j:
                                    pax_b = v[nodei.route.id][&#34;I&#34;][nodej]
                                    tv += (pax_b * 0.5 * tb) * dis_pax

                                # sentido de vuelta
                                else:
                                    pax_b = v[nodei.route.id][&#34;R&#34;][nodej]
                                    tv += (pax_b * 0.5 * tb) * dis_pax

                        # reportar ta
                        if isinstance(nodei, StopNode):
                            if isinstance(nodej, CityNode):
                                ta += nodei.mode.tat / 60
                        if isinstance(nodej, StopNode):
                            if isinstance(nodei, CityNode):
                                ta += nodej.mode.tat / 60

                        # agregamos elementos faltantes a las rutas
                        # si nodo i, nodo j y nodo k (new suc ) son de rutas entonces
                        for suc in successors[origin][destination][nodej]:
                            # agrega elementos para continuar rutas elementales
                            paths.append((nodej, suc.nodej, dis_pax))

                            # sumaremos tv producido por la espera de los que se bajan en paraderos cuando el ind sigue
                            # en ruta
                            # cbd                                 #SC                             #p
                            if isinstance(nodei, RouteNode) and isinstance(nodej, RouteNode) and isinstance(suc.nodej,
                                                                                                            RouteNode):
                                bya = nodei.route.mode.bya
                                tb = nodei.route.mode.t / 3600
                                # determinamos dirección
                                nodei_id = nodei.stop_node.city_node.graph_node.id
                                nodej_id = nodej.stop_node.city_node.graph_node.id

                                stop_sequence_i = nodei.route.stops_sequence_i

                                index = 0
                                index_i = 0
                                index_j = 0

                                for node_id in stop_sequence_i:
                                    if str(node_id) == str(nodei_id):
                                        index_i = index
                                    if str(node_id) == str(nodej_id):
                                        index_j = index
                                    index = index + 1

                                # verificamos si es del sentido de ida
                                if index_i &lt; index_j:
                                    # simultaneo
                                    if bya == 1:
                                        pasajeros = max(z[nodei.route.id][&#34;I&#34;][nodej.stop_node],
                                                        v[nodei.route.id][&#34;I&#34;][nodej.stop_node])
                                        tv += pasajeros * tb * dis_pax
                                    # secuencial
                                    if bya == 0:
                                        pasajeros = z[nodei.route.id][&#34;I&#34;][nodej.stop_node] + v[nodei.route.id][&#34;I&#34;][
                                            nodej.stop_node]
                                        tv += pasajeros * tb * dis_pax
                                # sentido de vuelta
                                else:
                                    # simultaneo
                                    if bya == 1:
                                        pasajeros = max(z[nodei.route.id][&#34;R&#34;][nodej.stop_node],
                                                        v[nodei.route.id][&#34;R&#34;][nodej.stop_node])
                                        tv += pasajeros * tb * dis_pax
                                    # secuencial
                                    if bya == 0:
                                        pasajeros = z[nodei.route.id][&#34;R&#34;][nodej.stop_node] + v[nodei.route.id][&#34;R&#34;][
                                            nodej.stop_node]
                                        tv += pasajeros * tb * dis_pax

        return ta, te, tv, t

    def get_users_cost(self, hyperpaths: dic_hyperpaths, Vij: dic_Vij, assignment: dic_assigment,
                       successors: dic_successors, extended_graph: ExtendedGraph, f: defaultdict_float,
                       passenger_obj: Passenger, z: defaultdict3_float, v: defaultdict3_float) -&gt; float:
        &#34;&#34;&#34;
        to get users cost
        :param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
        :param Vij: dic[origin: CityNode][destination: CityNode] = vij
        :param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
        :param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
        :param extended_graph: ExtendedGraph object
        :param f: dict with frequency [veh/hr] for each route_id
        :param passenger_obj: Passenger obj
        :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
        :return: float, users cost
        &#34;&#34;&#34;
        ta, te, tv, t = self.resources_consumer(hyperpaths, Vij, assignment, successors,
                                                extended_graph, passenger_obj.va, f, z, v)
        pa = passenger_obj.spa
        pv = passenger_obj.spv
        pw = passenger_obj.spw
        pt = passenger_obj.spt

        return ta * pa + te * pw + tv * pv + t * pt / 60 * pv</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sidermit.optimization.UsersCost.resources_consumer"><code class="name flex">
<span>def <span class="ident">resources_consumer</span></span>(<span>hyperpaths: defaultdict(<function <lambda> at 0x106CD978>, {}), Vij: defaultdict(<function <lambda> at 0x106CDC00>, {}), assignment: defaultdict(<function <lambda> at 0x106CDC48>, {}), successors: defaultdict(<function <lambda> at 0x106CDB70>, {}), extended_graph: <a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph" href="preoptimization/extended_graph.html#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph">ExtendedGraph</a>, vp: float, f: defaultdict(<class 'float'>, {}), z: defaultdict(<function <lambda> at 0x10624858>, {}), v: defaultdict(<function <lambda> at 0x106248A0>, {})) ‑> (<class 'float'>, <class 'float'>, <class 'float'>, <class 'int'>)</span>
</code></dt>
<dd>
<div class="desc"><p>to get resources consumer for all passenger in transport network access time, waiting time,
time on board of vehicle, numbers of transfer
:param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
:param Vij: dic[origin: CityNode][destination: CityNode] = vij
:param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
:param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
:param extended_graph: ExtendedGraph object
:param vp: passenger velocity [km/hr]
:param f: dict with frequency [veh/hr] for each route_id
:param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:return: (access time, waiting time, time on boad, numbers of transfers): (float, float, float, int)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def resources_consumer(hyperpaths: dic_hyperpaths, Vij: dic_Vij, assignment: dic_assigment,
                       successors: dic_successors, extended_graph: ExtendedGraph, vp: float, f: defaultdict_float,
                       z: defaultdict2_float, v: defaultdict3_float) -&gt; (float, float, float, int):
    &#34;&#34;&#34;
    to get resources consumer for all passenger in transport network access time, waiting time,
    time on board of vehicle, numbers of transfer
    :param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
    :param Vij: dic[origin: CityNode][destination: CityNode] = vij
    :param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
    :param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
    :param extended_graph: ExtendedGraph object
    :param vp: passenger velocity [km/hr]
    :param f: dict with frequency [veh/hr] for each route_id
    :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :return: (access time, waiting time, time on boad, numbers of transfers): (float, float, float, int)
    &#34;&#34;&#34;
    ta = 0
    tv = 0
    te = 0
    t = 0

    edges = extended_graph.get_extended_graph_edges()

    for origin in hyperpaths:
        for destination in hyperpaths[origin]:
            # viajes del par OD
            vod = Vij[origin][destination]
            for stop in hyperpaths[origin][destination]:
                # viajes de todas las rutas elementales que salen de esta parada
                vod_s = vod * assignment[origin][destination][stop] / 100

                if vod_s == 0:
                    continue

                paths = []

                for suc in successors[origin][destination][stop]:
                    nodej = suc.nodej
                    paths.append((stop, nodej, vod_s))

                # reportar ta inicial (lateral y tecnologico)
                ta += vod_s * (stop.mode.tat / 60 + assignment[origin][destination][
                    stop] / 100 * origin.graph_node.width / (4 * vp * stop.mode.d))

                while len(paths) != 0:
                    nodei, nodej, pax = paths.pop(0)

                    # evita continuar si llegaste a destino
                    if isinstance(nodei, StopNode) and nodei.city_node == destination:
                        continue

                    dis_pax = pax

                    # reportar te
                    if isinstance(nodei, StopNode):
                        if isinstance(nodej, RouteNode):

                            f_acum = 0

                            for suc in successors[origin][destination][nodei]:
                                f_acum += f[suc.nodej.route.id]

                            dis_pax = dis_pax * (f[nodej.route.id] / f_acum)

                            te += dis_pax * nodei.mode.theta / (f_acum / nodej.route.mode.d)

                    # reportar tv
                    if isinstance(nodei, RouteNode):
                        if isinstance(nodej, RouteNode):
                            for edge in edges:
                                if edge.nodei == nodei and edge.nodej == nodej:
                                    tv += dis_pax * edge.t
                                    break

                    # reportar transbordos y tv de bajada
                    if isinstance(nodei, RouteNode):
                        if isinstance(nodej, StopNode):
                            # transbordos
                            if nodej.city_node != destination:
                                t += dis_pax

                            # para tiempo de viaje adicional por esperar la bajada del vehiculo
                            nodei_id = nodei.prev_route_node.stop_node.city_node.graph_node.id
                            nodej_id = nodei.stop_node.city_node.graph_node.id

                            stop_sequence_i = nodei.route.stops_sequence_i

                            index = 0
                            index_i = 0
                            index_j = 0

                            for node_id in stop_sequence_i:
                                if str(node_id) == str(nodei_id):
                                    index_i = index
                                if str(node_id) == str(nodej_id):
                                    index_j = index
                                index = index + 1

                            tb = nodei.route.mode.t / 3600
                            # verificamos si es del sentido de ida
                            if index_i &lt; index_j:
                                pax_b = v[nodei.route.id][&#34;I&#34;][nodej]
                                tv += (pax_b * 0.5 * tb) * dis_pax

                            # sentido de vuelta
                            else:
                                pax_b = v[nodei.route.id][&#34;R&#34;][nodej]
                                tv += (pax_b * 0.5 * tb) * dis_pax

                    # reportar ta
                    if isinstance(nodei, StopNode):
                        if isinstance(nodej, CityNode):
                            ta += nodei.mode.tat / 60
                    if isinstance(nodej, StopNode):
                        if isinstance(nodei, CityNode):
                            ta += nodej.mode.tat / 60

                    # agregamos elementos faltantes a las rutas
                    # si nodo i, nodo j y nodo k (new suc ) son de rutas entonces
                    for suc in successors[origin][destination][nodej]:
                        # agrega elementos para continuar rutas elementales
                        paths.append((nodej, suc.nodej, dis_pax))

                        # sumaremos tv producido por la espera de los que se bajan en paraderos cuando el ind sigue
                        # en ruta
                        # cbd                                 #SC                             #p
                        if isinstance(nodei, RouteNode) and isinstance(nodej, RouteNode) and isinstance(suc.nodej,
                                                                                                        RouteNode):
                            bya = nodei.route.mode.bya
                            tb = nodei.route.mode.t / 3600
                            # determinamos dirección
                            nodei_id = nodei.stop_node.city_node.graph_node.id
                            nodej_id = nodej.stop_node.city_node.graph_node.id

                            stop_sequence_i = nodei.route.stops_sequence_i

                            index = 0
                            index_i = 0
                            index_j = 0

                            for node_id in stop_sequence_i:
                                if str(node_id) == str(nodei_id):
                                    index_i = index
                                if str(node_id) == str(nodej_id):
                                    index_j = index
                                index = index + 1

                            # verificamos si es del sentido de ida
                            if index_i &lt; index_j:
                                # simultaneo
                                if bya == 1:
                                    pasajeros = max(z[nodei.route.id][&#34;I&#34;][nodej.stop_node],
                                                    v[nodei.route.id][&#34;I&#34;][nodej.stop_node])
                                    tv += pasajeros * tb * dis_pax
                                # secuencial
                                if bya == 0:
                                    pasajeros = z[nodei.route.id][&#34;I&#34;][nodej.stop_node] + v[nodei.route.id][&#34;I&#34;][
                                        nodej.stop_node]
                                    tv += pasajeros * tb * dis_pax
                            # sentido de vuelta
                            else:
                                # simultaneo
                                if bya == 1:
                                    pasajeros = max(z[nodei.route.id][&#34;R&#34;][nodej.stop_node],
                                                    v[nodei.route.id][&#34;R&#34;][nodej.stop_node])
                                    tv += pasajeros * tb * dis_pax
                                # secuencial
                                if bya == 0:
                                    pasajeros = z[nodei.route.id][&#34;R&#34;][nodej.stop_node] + v[nodei.route.id][&#34;R&#34;][
                                        nodej.stop_node]
                                    tv += pasajeros * tb * dis_pax

    return ta, te, tv, t</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sidermit.optimization.UsersCost.get_users_cost"><code class="name flex">
<span>def <span class="ident">get_users_cost</span></span>(<span>self, hyperpaths: defaultdict(<function <lambda> at 0x106CD978>, {}), Vij: defaultdict(<function <lambda> at 0x106CDC00>, {}), assignment: defaultdict(<function <lambda> at 0x106CDC48>, {}), successors: defaultdict(<function <lambda> at 0x106CDB70>, {}), extended_graph: <a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph" href="preoptimization/extended_graph.html#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph">ExtendedGraph</a>, f: defaultdict(<class 'float'>, {}), passenger_obj: <a title="sidermit.publictransportsystem.passenger.Passenger" href="../publictransportsystem/passenger.html#sidermit.publictransportsystem.passenger.Passenger">Passenger</a>, z: defaultdict(<function <lambda> at 0x106248A0>, {}), v: defaultdict(<function <lambda> at 0x106248A0>, {})) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>to get users cost
:param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
:param Vij: dic[origin: CityNode][destination: CityNode] = vij
:param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
:param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
:param extended_graph: ExtendedGraph object
:param f: dict with frequency [veh/hr] for each route_id
:param passenger_obj: Passenger obj
:param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
:return: float, users cost</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_users_cost(self, hyperpaths: dic_hyperpaths, Vij: dic_Vij, assignment: dic_assigment,
                   successors: dic_successors, extended_graph: ExtendedGraph, f: defaultdict_float,
                   passenger_obj: Passenger, z: defaultdict3_float, v: defaultdict3_float) -&gt; float:
    &#34;&#34;&#34;
    to get users cost
    :param hyperpaths: Dic[origin: CityNode][destination: CityNode][StopNode] = List[List[ExtendedNodes]]
    :param Vij: dic[origin: CityNode][destination: CityNode] = vij
    :param assignment: dic[origin: CityNode][destination: CityNode][Stop: StopNode] = %V_OD
    :param successors: dic[origin: CityNode][destination: CityNode][ExtendedNode] = List[ExtendedEdge]
    :param extended_graph: ExtendedGraph object
    :param f: dict with frequency [veh/hr] for each route_id
    :param passenger_obj: Passenger obj
    :param z: boarding, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :param v: alighting, dic[route_id][direction][stop: StopNode] = pax [pax/veh]
    :return: float, users cost
    &#34;&#34;&#34;
    ta, te, tv, t = self.resources_consumer(hyperpaths, Vij, assignment, successors,
                                            extended_graph, passenger_obj.va, f, z, v)
    pa = passenger_obj.spa
    pv = passenger_obj.spv
    pw = passenger_obj.spw
    pt = passenger_obj.spt

    return ta * pa + te * pw + tv * pv + t * pt / 60 * pv</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sidermit" href="../index.html">sidermit</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="sidermit.optimization.constrains" href="constrains.html">sidermit.optimization.constrains</a></code></li>
<li><code><a title="sidermit.optimization.infrastructure_cost" href="infrastructure_cost.html">sidermit.optimization.infrastructure_cost</a></code></li>
<li><code><a title="sidermit.optimization.operators_cost" href="operators_cost.html">sidermit.optimization.operators_cost</a></code></li>
<li><code><a title="sidermit.optimization.optimizer" href="optimizer.html">sidermit.optimization.optimizer</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization" href="preoptimization/index.html">sidermit.optimization.preoptimization</a></code></li>
<li><code><a title="sidermit.optimization.users_cost" href="users_cost.html">sidermit.optimization.users_cost</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sidermit.optimization.Constrains" href="#sidermit.optimization.Constrains">Constrains</a></code></h4>
<ul class="">
<li><code><a title="sidermit.optimization.Constrains.fmax_constrains" href="#sidermit.optimization.Constrains.fmax_constrains">fmax_constrains</a></code></li>
<li><code><a title="sidermit.optimization.Constrains.most_loaded_section_constrains" href="#sidermit.optimization.Constrains.most_loaded_section_constrains">most_loaded_section_constrains</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sidermit.optimization.InfrastructureCost" href="#sidermit.optimization.InfrastructureCost">InfrastructureCost</a></code></h4>
<ul class="">
<li><code><a title="sidermit.optimization.InfrastructureCost.get_infrastruture_cost" href="#sidermit.optimization.InfrastructureCost.get_infrastruture_cost">get_infrastruture_cost</a></code></li>
<li><code><a title="sidermit.optimization.InfrastructureCost.get_mode_network_distance" href="#sidermit.optimization.InfrastructureCost.get_mode_network_distance">get_mode_network_distance</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sidermit.optimization.OperatorsCost" href="#sidermit.optimization.OperatorsCost">OperatorsCost</a></code></h4>
<ul class="">
<li><code><a title="sidermit.optimization.OperatorsCost.get_cycle_time" href="#sidermit.optimization.OperatorsCost.get_cycle_time">get_cycle_time</a></code></li>
<li><code><a title="sidermit.optimization.OperatorsCost.get_operators_cost" href="#sidermit.optimization.OperatorsCost.get_operators_cost">get_operators_cost</a></code></li>
<li><code><a title="sidermit.optimization.OperatorsCost.lines_travel_time" href="#sidermit.optimization.OperatorsCost.lines_travel_time">lines_travel_time</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sidermit.optimization.Optimizer" href="#sidermit.optimization.Optimizer">Optimizer</a></code></h4>
<ul class="">
<li><code><a title="sidermit.optimization.Optimizer.VRC" href="#sidermit.optimization.Optimizer.VRC">VRC</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.constrains" href="#sidermit.optimization.Optimizer.constrains">constrains</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.external_optimization" href="#sidermit.optimization.Optimizer.external_optimization">external_optimization</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.external_optimization_tolerance" href="#sidermit.optimization.Optimizer.external_optimization_tolerance">external_optimization_tolerance</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.f0" href="#sidermit.optimization.Optimizer.f0">f0</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.f_distance" href="#sidermit.optimization.Optimizer.f_distance">f_distance</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.fopt_to_f" href="#sidermit.optimization.Optimizer.fopt_to_f">fopt_to_f</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.get_better_result" href="#sidermit.optimization.Optimizer.get_better_result">get_better_result</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.get_constrains" href="#sidermit.optimization.Optimizer.get_constrains">get_constrains</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.get_k" href="#sidermit.optimization.Optimizer.get_k">get_k</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.get_network_results" href="#sidermit.optimization.Optimizer.get_network_results">get_network_results</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.get_optimization_value" href="#sidermit.optimization.Optimizer.get_optimization_value">get_optimization_value</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.get_overall_results" href="#sidermit.optimization.Optimizer.get_overall_results">get_overall_results</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.infrastructure_cost" href="#sidermit.optimization.Optimizer.infrastructure_cost">infrastructure_cost</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.internal_optimization" href="#sidermit.optimization.Optimizer.internal_optimization">internal_optimization</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.last_iteration" href="#sidermit.optimization.Optimizer.last_iteration">last_iteration</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.network_optimization" href="#sidermit.optimization.Optimizer.network_optimization">network_optimization</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.operators_cost" href="#sidermit.optimization.Optimizer.operators_cost">operators_cost</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.status_optimization" href="#sidermit.optimization.Optimizer.status_optimization">status_optimization</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.string_information_internal_optimization" href="#sidermit.optimization.Optimizer.string_information_internal_optimization">string_information_internal_optimization</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.string_network_optimization" href="#sidermit.optimization.Optimizer.string_network_optimization">string_network_optimization</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.string_network_results" href="#sidermit.optimization.Optimizer.string_network_results">string_network_results</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.string_overall_results" href="#sidermit.optimization.Optimizer.string_overall_results">string_overall_results</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.user_cost" href="#sidermit.optimization.Optimizer.user_cost">user_cost</a></code></li>
<li><code><a title="sidermit.optimization.Optimizer.write_file_network_results" href="#sidermit.optimization.Optimizer.write_file_network_results">write_file_network_results</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sidermit.optimization.UsersCost" href="#sidermit.optimization.UsersCost">UsersCost</a></code></h4>
<ul class="">
<li><code><a title="sidermit.optimization.UsersCost.get_users_cost" href="#sidermit.optimization.UsersCost.get_users_cost">get_users_cost</a></code></li>
<li><code><a title="sidermit.optimization.UsersCost.resources_consumer" href="#sidermit.optimization.UsersCost.resources_consumer">resources_consumer</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>