<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.1" />
<title>sidermit.optimization.preoptimization.extended_graph API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sidermit.optimization.preoptimization.extended_graph</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import defaultdict
from enum import Enum
from typing import List

from sidermit.city import Graph, Node
from sidermit.publictransportsystem import TransportMode, Route
from sidermit.publictransportsystem.network import RouteType


#                                    Representation extended graph
#
# for each p,sc y CBD:                _______________city_node_______________
#                                     ↑                  ↑                   ↑
#                                access_edge        access_edge          access_edge
#                                     ↓                  ↓                   ↓
# for each mode:                  stop_node (mode1)  stop_node (mode2)    stop_node (mode3)
#                                 |       ↑          |       ↑            |       ↑
#                             boarding alighting  boarding alighting   boarding alighting
#                               edge      edge      edge     edge        edge     edge
#                                 ↓       |          ↓       |            ↓       |
# for each route, direction      route_node           route_node          route_node
#                                     ↑                    ↑                   ↑
#                                route_edge             route_edge         route_edge
#                                     ↑                    ↑                   ↑
# relation with other city_node  route_node(i-1)      route_node(i-1)     route_node(i-1)

class ExtendedNode:

    def __init__(self, extendend_node_id):
        &#34;&#34;&#34;
        node to extended graph
        :param extendend_node_id: node id
        &#34;&#34;&#34;
        self.id = extendend_node_id


class CityNode(ExtendedNode):

    def __init__(self, city_node_id, graph_node: Node):
        &#34;&#34;&#34;
        extended node with graph node information
        :param city_node_id: node id
        :param graph_node: CBD, Subcenter or Periphery node
        &#34;&#34;&#34;
        ExtendedNode.__init__(self, city_node_id)
        self.graph_node = graph_node


class StopNode(ExtendedNode):
    def __init__(self, stop_node_id, mode_obj: TransportMode, city_node: CityNode):
        &#34;&#34;&#34;
        extended node with Transport Mode information
        :param stop_node_id: node id
        :param mode_obj: TransportMode object
        :param city_node: CityNode object associated
        &#34;&#34;&#34;
        ExtendedNode.__init__(self, stop_node_id)
        self.mode = mode_obj
        self.city_node = city_node


class RouteNode(ExtendedNode):
    def __init__(self, route_node_id, route_obj: Route, direction: str, stop_node: StopNode, previous=None):
        &#34;&#34;&#34;
        extended node with route information
        :param route_node_id: node id
        :param route_obj: Route object
        :param direction: &#34;I&#34; if RouteNode represents forward direction, &#34;R&#34; if RouteNode represents return direction
        :param stop_node: StopNode object associated
        :param previous: previous RouteNode in stop sequences of the route associated
        &#34;&#34;&#34;
        ExtendedNode.__init__(self, route_node_id)
        self.route = route_obj
        self.direction = direction
        self.stop_node = stop_node
        self.prev_route_node = previous


class ExtendedEdge:
    def __init__(self, extended_edge_id, nodei, nodej, t, f, edge_type):
        &#34;&#34;&#34;
        edge to extended graph
        :param extended_edge_id: edge id
        :param nodei: edge origin node
        :param nodej: edge detination node
        :param t: edge time in hours
        :param f: edge frequency in [veh/hr]
        :param edge_type: edge type (ExtendedEdgesType)
        &#34;&#34;&#34;
        self.id = extended_edge_id
        self.nodei = nodei
        self.nodej = nodej
        self.t = t
        self.f = f
        self.type = edge_type


class ExtendedEdgesType(Enum):
    &#34;&#34;&#34;
    extended edges type. ACCESS edge to edges between CityNode and StopNode and vice versa, Boarding edge to edges
    between StopNode and RouteNode, ALIGHTING edge to edges between RouteNode and StopNode, Route edge to edges
    between RouteNode and RouteNode
    &#34;&#34;&#34;
    ACCESS = 1
    BOARDING = 2
    ALIGHTING = 3
    ROUTE = 4


defaultdict_float = defaultdict(float)
defaultdict2_route_node = defaultdict(lambda: defaultdict(List[RouteNode]))
defaultdict2_route_direction = defaultdict(lambda: defaultdict(List[Route, str]))


class ExtendedGraph:

    def __init__(self, graph_obj: Graph, routes: List[Route], TP: float, frequency_routes: defaultdict_float = None):
        &#34;&#34;&#34;
        class to create extended graph that agglomerates the city graph information and transport routes in the network.
        It incorporates the penalty of the transfer of the passenger and the frequencies of the routes for
        the construction of edges
        :param graph_obj: Graph object
        :param routes: list of routes in network associated
        :param TP: penalty of the transfer of the passenger in EIV
        :param frequency_routes: defauldict(float) with key: route_id and value: frequency [veh/hr] of the route_id.
        Default value is a a dictionary with a frequency of 28 [veh/hr] for all routes
        &#34;&#34;&#34;

        if frequency_routes is None:
            frequency_routes = defaultdict(float)

            for route in routes:
                frequency_routes[route.id] = route.mode.fini

        # list with all city_nodes
        city_nodes = self.build_city_nodes(graph_obj)

        # assistant dictionary to build stop_nodes and routes_nodes: dic[city_node][mode_obj] = [list of routes]
        tree_graph = self.build_tree_graph(routes, city_nodes)

        # list with all stop nodes, there are 1 stop_node for each mode transiting in a city_node
        stop_nodes = self.build_stop_nodes(tree_graph)

        # list with all route_nodes, there are 1 route_node connected to a stop_node for each route in a city_node
        route_nodes = self.build_route_nodes(routes, stop_nodes)

        # extended graph nodes like as a dictionary: dic[city_node][stop_node] = [list route_nodes]
        self.__extended_graph_nodes = self.build_extended_graph_nodes(route_nodes)

        # list with all access edges, edges between city_node&lt;-&gt;stop_node
        access_edges = self.build_access_edges(self.__extended_graph_nodes)
        # list with all boarding edges, edges between stop_node-&gt;route_node
        boarding_edges = self.build_boarding_edges(self.__extended_graph_nodes, frequency_routes)
        # list with all alighting edges, edges between route_node-&gt;stop_node
        alighting_edges = self.build_alighting_edges(self.__extended_graph_nodes, TP)
        # list with all routes edges, edges between route_node(i-1)-&gt;route_node(i)
        routes_edges = self.build_route_edges(self.__extended_graph_nodes)

        self.__extended_graph_edges = []

        for edge in access_edges:
            self.__extended_graph_edges.append(edge)
        for edge in boarding_edges:
            self.__extended_graph_edges.append(edge)
        for edge in alighting_edges:
            self.__extended_graph_edges.append(edge)
        for edge in routes_edges:
            self.__extended_graph_edges.append(edge)

    def __str__(self):
        &#34;&#34;&#34;
        to print extended graph
        :return: String with information of the extended graph
        &#34;&#34;&#34;
        line = &#34;&#34;
        for city_node in self.__extended_graph_nodes:
            line += &#34;City node\n-Graph node name: {}\n&#34;.format(city_node.graph_node.name)
            for stop_node in self.__extended_graph_nodes[city_node]:
                # information about access edge
                for edge in self.__extended_graph_edges:
                    if edge.nodei == city_node and edge.nodej == stop_node:
                        line += &#34;\tAccess edge\n\t-Access time: {:.2f} [min]\n&#34;.format(edge.t)

                line += &#34;\t\tStop node\n\t\t-Mode name: {}\n&#34;.format(stop_node.mode.name)

                for route_node in self.__extended_graph_nodes[city_node][stop_node]:
                    # information about boarding edge
                    for edge in self.__extended_graph_edges:
                        if edge.nodei == stop_node and edge.nodej == route_node:
                            line += &#34;\t\t\tBoarding edge\n\t\t\t-Frequency: {:.2f} [veh/h]\n&#34;.format(edge.f)

                    # information about boarding edge
                    for edge in self.__extended_graph_edges:
                        if edge.nodei == route_node and edge.nodej == stop_node:
                            line += &#34;\t\t\tAlighting edge\n\t\t\t-Penalty transfer: {:.2f} [min]\n&#34;.format(edge.t * 60)

                    # information about route node
                    if route_node.prev_route_node is None:
                        line += &#34;\t\t\t\tRoute node\n\t\t\t\t-Route_id: {}\n\t\t\t\t-Direction: {}\n\t\t\t\t-Previous stop: {}\n\t\t\t\t-Time to previous stop: {:.2f} [hrs]\n&#34;.format(
                            route_node.route.id,
                            route_node.direction, &#34;no data&#34;, 0)
                    else:
                        t = 0
                        for edge in self.__extended_graph_edges:
                            if edge.nodei == route_node.prev_route_node and edge.nodej == route_node:
                                t = edge.t
                                break
                        line += &#34;\t\t\t\tRoute node\n\t\t\t\t-Route_id: {}\n\t\t\t\t-Direction: {}\n\t\t\t\t-Previous stop: {}\n\t\t\t\t-Time to previous stop: {} [hrs]\n&#34;.format(
                            route_node.route.id,
                            route_node.direction,
                            route_node.prev_route_node.stop_node.city_node.graph_node.name,
                            t)
        return line

    def get_extended_graph_nodes(self) -&gt; defaultdict2_route_node:
        &#34;&#34;&#34;
        to get extended nodes associated to the graph
        :return: dictionary: dic[CityNode][StopNode] = List[RouteNode]
        &#34;&#34;&#34;
        return self.__extended_graph_nodes

    def get_extended_graph_edges(self) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to get extended edges associated to the graph
        :return: List[ExtendedEdges]
        &#34;&#34;&#34;
        return self.__extended_graph_edges

    @staticmethod
    def build_city_nodes(graph_obj: Graph) -&gt; List[CityNode]:
        &#34;&#34;&#34;
        to build CityNodes in the extended graph
        :param graph_obj: Graph object
        :return: List[CityNode]
        &#34;&#34;&#34;
        city_nodes = []
        for node in graph_obj.get_nodes():
            city_node = CityNode(len(city_nodes), node)
            city_nodes.append(city_node)
        return city_nodes

    @staticmethod
    def build_tree_graph(routes: List[Route], city_nodes: List[CityNode]) -&gt; defaultdict2_route_direction:
        &#34;&#34;&#34;
        to build auxiliary structure for construction of the extended graph
        :param routes: routes in the network associated
        :param city_nodes: List[CityNode]
        :return: dictionary: dic[CityNode][TransportMode] = List(Route, direction = &#34;I&#34; or &#34;R&#34;)
        &#34;&#34;&#34;

        tree_graph = defaultdict(lambda: defaultdict(list))
        for city_node in city_nodes:
            node_graph_id = city_node.graph_node.id

            for route in routes:
                mode_obj = route.mode
                stops_i = route.stops_sequence_i
                stops_r = route.stops_sequence_r

                for stop in stops_i:
                    if str(node_graph_id) == str(stop):
                        # to avoid add twice first and last node in circular routes
                        if route._type == RouteType.PREDEFINED or route._type == RouteType.CIRCULAR:
                            if (route, &#34;I&#34;) not in tree_graph[city_node][mode_obj]:
                                tree_graph[city_node][mode_obj].append((route, &#34;I&#34;))
                        else:
                            tree_graph[city_node][mode_obj].append((route, &#34;I&#34;))

                for stop in stops_r:
                    if str(node_graph_id) == str(stop):
                        # to avoid add twice first and last node in circular routes
                        if route._type == RouteType.PREDEFINED or route._type == RouteType.CIRCULAR:
                            if (route, &#34;R&#34;) not in tree_graph[city_node][mode_obj]:
                                tree_graph[city_node][mode_obj].append((route, &#34;R&#34;))
                        else:
                            tree_graph[city_node][mode_obj].append((route, &#34;R&#34;))

        return tree_graph

    @staticmethod
    def build_stop_nodes(tree_graph: defaultdict2_route_direction) -&gt; List[StopNode]:
        &#34;&#34;&#34;
        to build StopNode in extended graph
        :param tree_graph: dic[CityNode][TransportMode] = List(Route, direction = &#34;I&#34; or &#34;R&#34;)
        :return: List[StopNode]
        &#34;&#34;&#34;
        # list with tuples (mode_obj, city_node) to not duplicated more of a stop for each mode in a city_node
        mode_city = []
        stop_nodes = []
        for city_node in tree_graph:
            for mode_obj in tree_graph[city_node]:
                if (mode_obj, city_node) not in mode_city:
                    mode_city.append((mode_obj, city_node))
                    stop_node = StopNode(len(stop_nodes), mode_obj, city_node)
                    stop_nodes.append(stop_node)
        return stop_nodes

    @staticmethod
    def build_route_nodes(routes: List[Route], stop_nodes: List[StopNode]) -&gt; List[RouteNode]:
        &#34;&#34;&#34;
        to build route nodes in extended graph
        :param routes: list of routes in network associated
        :param stop_nodes: List[StopNode]
        :return: List[RouteNode]
        &#34;&#34;&#34;
        # list with all route nodes
        route_nodes = []
        for route in routes:
            mode = route.mode
            stop_i = route.stops_sequence_i
            stop_r = route.stops_sequence_r
            # to circular exceptions
            _type = route._type

            # nodes for &#34;I&#34; direction
            nodes = []
            prev_route_node = None
            # look for a previous route node
            for stop in stop_i:
                stop_node = None
                for s in stop_nodes:
                    if s.mode == mode and str(s.city_node.graph_node.id) == str(stop):
                        stop_node = s
                        break
                route_node = RouteNode(len(route_nodes) + len(nodes), route, &#34;I&#34;, stop_node, prev_route_node)
                prev_route_node = route_node
                nodes.append(route_node)
            # add previous node_route in circular routes
            if prev_route_node is not None and _type == RouteType.CIRCULAR:
                for i in range(len(nodes)):
                    if i == 0:
                        continue
                    n = nodes[i]
                    if i == 1:
                        n.prev_route_node = nodes[len(nodes) - 1]
                        route_nodes.append(n)
                        continue
                    n = nodes[i]
                    route_nodes.append(n)
            # add previous node_route
            if _type == RouteType.PREDEFINED or _type == RouteType.CUSTOM:
                for n in nodes:
                    route_nodes.append(n)
            # nodes for &#34;R&#34; direction
            nodes = []
            prev_route_node = None
            # look for a previous route node
            for stop in stop_r:
                stop_node = None
                for s in stop_nodes:
                    if s.mode == mode and str(s.city_node.graph_node.id) == str(stop):
                        stop_node = s
                        break
                route_node = RouteNode(len(route_nodes) + len(nodes), route, &#34;R&#34;, stop_node, prev_route_node)
                prev_route_node = route_node
                nodes.append(route_node)
            # add previous node_route in circular routes
            if prev_route_node is not None and _type == RouteType.CIRCULAR:
                for i in range(len(nodes)):
                    if i == 0:
                        continue
                    n = nodes[i]
                    if i == 1:
                        n.prev_route_node = nodes[len(nodes) - 1]
                        route_nodes.append(n)
                        continue
                    n = nodes[i]
                    route_nodes.append(n)
            # add previous node_route
            if _type == RouteType.PREDEFINED or _type == RouteType.CUSTOM:
                for n in nodes:
                    route_nodes.append(n)

        return route_nodes

    @staticmethod
    def build_extended_graph_nodes(route_nodes: List[RouteNode]) -&gt; defaultdict2_route_node:
        &#34;&#34;&#34;
        to build extended graph node structure
        :param route_nodes: List[RouteNode]
        :return: dictionary: dic[CityNode][StopNode] = List[RouteNode]
        &#34;&#34;&#34;

        extended_graph_nodes = defaultdict(lambda: defaultdict(list))
        for route_node in route_nodes:
            stop_node = route_node.stop_node
            city_node = stop_node.city_node
            extended_graph_nodes[city_node][stop_node].append(route_node)

        return extended_graph_nodes

    @staticmethod
    def build_access_edges(extended_graph_nodes: defaultdict2_route_node) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build access edges in extended graph
        :param extended_graph_nodes: dictionary: dic[CityNode][StopNode] = List[RouteNode]
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;
        access_edges = []
        for city_node in extended_graph_nodes:
            for stop_node in extended_graph_nodes[city_node]:
                edge1 = ExtendedEdge(len(access_edges), city_node, stop_node,
                                     stop_node.mode.tat / 60, float(&#39;inf&#39;), ExtendedEdgesType.ACCESS)
                access_edges.append(edge1)
                edge2 = ExtendedEdge(len(access_edges), stop_node, city_node,
                                     stop_node.mode.tat / 60, float(&#39;inf&#39;), ExtendedEdgesType.ACCESS)
                access_edges.append(edge2)
        return access_edges

    @staticmethod
    def build_boarding_edges(extended_graph_nodes: defaultdict2_route_node, frequency_routes: defaultdict_float) -&gt; \
            List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build boarding edges in extended graph
        :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
        :param frequency_routes: defauldict(float) with key: route_id and value: frequency [veh/hr] of the route_id.
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;
        boarding_edges = []
        for city_node in extended_graph_nodes:
            for stop_node in extended_graph_nodes[city_node]:
                for route_node in extended_graph_nodes[city_node][stop_node]:
                    route = route_node.route
                    direction = route_node.direction

                    if direction == &#34;I&#34;:
                        node_sequence = route.nodes_sequence_i
                    else:
                        node_sequence = route.nodes_sequence_r
                    # if not be last stop of the route add boarding edges
                    if route._type != RouteType.CIRCULAR and str(route_node.stop_node.city_node.graph_node.id) != str(
                            node_sequence[len(node_sequence) - 1]):
                        edge = ExtendedEdge(len(boarding_edges), stop_node, route_node,
                                            0, frequency_routes[route.id] / route.mode.d, ExtendedEdgesType.BOARDING)
                        boarding_edges.append(edge)
                        continue
                    # but if route type is circular add always boarding edges
                    if route._type == RouteType.CIRCULAR:
                        edge = ExtendedEdge(len(boarding_edges), stop_node, route_node,
                                            0, frequency_routes[route.id] / route.mode.d, ExtendedEdgesType.BOARDING)
                        boarding_edges.append(edge)
                        continue

        return boarding_edges

    @staticmethod
    def build_alighting_edges(extended_graph_nodes: defaultdict2_route_node, sPTP: float) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build extended alighting edges
        :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
        :param sPTP: penalty of the transfer of the passenger in EIV
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;
        spt = sPTP / 60
        alighting_edges = []
        for city_node in extended_graph_nodes:
            for stop_node in extended_graph_nodes[city_node]:
                for route_node in extended_graph_nodes[city_node][stop_node]:
                    route = route_node.route
                    direction = route_node.direction
                    if direction == &#34;I&#34;:
                        node_sequence = route.nodes_sequence_i
                    else:
                        node_sequence = route.nodes_sequence_r
                    # if not be first stop of the route add alighting edges
                    if route._type != RouteType.CIRCULAR and str(route_node.stop_node.city_node.graph_node.id) != str(
                            node_sequence[0]):
                        edge = ExtendedEdge(len(alighting_edges), route_node, stop_node,
                                            spt, float(&#39;inf&#39;), ExtendedEdgesType.ALIGHTING)
                        alighting_edges.append(edge)
                        continue
                    # but if route type is circular add always alighting edges
                    if route._type == RouteType.CIRCULAR:
                        edge = ExtendedEdge(len(alighting_edges), route_node, stop_node,
                                            spt, float(&#39;inf&#39;), ExtendedEdgesType.ALIGHTING)
                        alighting_edges.append(edge)
                        continue

        return alighting_edges

    @staticmethod
    def build_route_edges(extended_graph_nodes: defaultdict2_route_node) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build extended routes edges
        :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;

        route_nodes = []
        nodes = []

        for city_node in extended_graph_nodes:
            nodes.append(city_node.graph_node)
            for stop_node in extended_graph_nodes[city_node]:
                for route_node in extended_graph_nodes[city_node][stop_node]:
                    route_nodes.append(route_node)

        route_edges = []
        for route_node in route_nodes:
            # only if route node has previous route node
            if route_node.prev_route_node is not None:

                # previous route node
                previous_route_node = route_node.prev_route_node

                # to identify route
                route = route_node.route
                direction = route_node.direction

                # velocity of the route
                v = route_node.stop_node.mode.v

                # id graph node to actual route node and previous route node
                id_city1 = route_node.stop_node.city_node.graph_node.id
                id_city2 = previous_route_node.stop_node.city_node.graph_node.id

                # to identify node sequence of the route
                if direction == &#34;I&#34;:
                    node_sequence = route.nodes_sequence_i
                else:
                    node_sequence = route.nodes_sequence_r

                # to get distance between actual route node and previous route node
                distance = 0
                x_prev = previous_route_node.stop_node.city_node.graph_node.x
                y_prev = previous_route_node.stop_node.city_node.graph_node.y
                x_final = route_node.stop_node.city_node.graph_node.x
                y_final = route_node.stop_node.city_node.graph_node.y
                count = False
                for node in node_sequence:
                    if str(node) == str(id_city2):
                        count = True
                        continue
                    if str(node) == str(id_city1):
                        distance = distance + ((x_prev - x_final) ** 2 + (y_prev - y_final) ** 2) ** 0.5
                        break
                    if count:
                        for n in nodes:
                            if str(node) == str(n.id):
                                x = n.x
                                y = n.y
                                distance = distance + ((x_prev - x) ** 2 + (y_prev - y) ** 2) ** 0.5
                                x_prev = x
                                y_prev = y
                                break

                t = distance / v

                edge = ExtendedEdge(len(route_edges), previous_route_node, route_node,
                                    t, float(&#39;inf&#39;), ExtendedEdgesType.ROUTE)
                route_edges.append(edge)
        return route_edges</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sidermit.optimization.preoptimization.extended_graph.CityNode"><code class="flex name class">
<span>class <span class="ident">CityNode</span></span>
<span>(</span><span>city_node_id, graph_node: <a title="sidermit.city.graph.Node" href="../../city/graph.html#sidermit.city.graph.Node">Node</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>extended node with graph node information
:param city_node_id: node id
:param graph_node: CBD, Subcenter or Periphery node</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CityNode(ExtendedNode):

    def __init__(self, city_node_id, graph_node: Node):
        &#34;&#34;&#34;
        extended node with graph node information
        :param city_node_id: node id
        :param graph_node: CBD, Subcenter or Periphery node
        &#34;&#34;&#34;
        ExtendedNode.__init__(self, city_node_id)
        self.graph_node = graph_node</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedNode" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedNode">ExtendedNode</a></li>
</ul>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedEdge"><code class="flex name class">
<span>class <span class="ident">ExtendedEdge</span></span>
<span>(</span><span>extended_edge_id, nodei, nodej, t, f, edge_type)</span>
</code></dt>
<dd>
<div class="desc"><p>edge to extended graph
:param extended_edge_id: edge id
:param nodei: edge origin node
:param nodej: edge detination node
:param t: edge time in hours
:param f: edge frequency in [veh/hr]
:param edge_type: edge type (ExtendedEdgesType)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedEdge:
    def __init__(self, extended_edge_id, nodei, nodej, t, f, edge_type):
        &#34;&#34;&#34;
        edge to extended graph
        :param extended_edge_id: edge id
        :param nodei: edge origin node
        :param nodej: edge detination node
        :param t: edge time in hours
        :param f: edge frequency in [veh/hr]
        :param edge_type: edge type (ExtendedEdgesType)
        &#34;&#34;&#34;
        self.id = extended_edge_id
        self.nodei = nodei
        self.nodej = nodej
        self.t = t
        self.f = f
        self.type = edge_type</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType"><code class="flex name class">
<span>class <span class="ident">ExtendedEdgesType</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>extended edges type. ACCESS edge to edges between CityNode and StopNode and vice versa, Boarding edge to edges
between StopNode and RouteNode, ALIGHTING edge to edges between RouteNode and StopNode, Route edge to edges
between RouteNode and RouteNode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedEdgesType(Enum):
    &#34;&#34;&#34;
    extended edges type. ACCESS edge to edges between CityNode and StopNode and vice versa, Boarding edge to edges
    between StopNode and RouteNode, ALIGHTING edge to edges between RouteNode and StopNode, Route edge to edges
    between RouteNode and RouteNode
    &#34;&#34;&#34;
    ACCESS = 1
    BOARDING = 2
    ALIGHTING = 3
    ROUTE = 4</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ACCESS"><code class="name">var <span class="ident">ACCESS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ALIGHTING"><code class="name">var <span class="ident">ALIGHTING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.BOARDING"><code class="name">var <span class="ident">BOARDING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ROUTE"><code class="name">var <span class="ident">ROUTE</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph"><code class="flex name class">
<span>class <span class="ident">ExtendedGraph</span></span>
<span>(</span><span>graph_obj: <a title="sidermit.city.graph.Graph" href="../../city/graph.html#sidermit.city.graph.Graph">Graph</a>, routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], TP: float, frequency_routes: defaultdict(<class 'float'>, {}) = None)</span>
</code></dt>
<dd>
<div class="desc"><p>class to create extended graph that agglomerates the city graph information and transport routes in the network.
It incorporates the penalty of the transfer of the passenger and the frequencies of the routes for
the construction of edges
:param graph_obj: Graph object
:param routes: list of routes in network associated
:param TP: penalty of the transfer of the passenger in EIV
:param frequency_routes: defauldict(float) with key: route_id and value: frequency [veh/hr] of the route_id.
Default value is a a dictionary with a frequency of 28 [veh/hr] for all routes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedGraph:

    def __init__(self, graph_obj: Graph, routes: List[Route], TP: float, frequency_routes: defaultdict_float = None):
        &#34;&#34;&#34;
        class to create extended graph that agglomerates the city graph information and transport routes in the network.
        It incorporates the penalty of the transfer of the passenger and the frequencies of the routes for
        the construction of edges
        :param graph_obj: Graph object
        :param routes: list of routes in network associated
        :param TP: penalty of the transfer of the passenger in EIV
        :param frequency_routes: defauldict(float) with key: route_id and value: frequency [veh/hr] of the route_id.
        Default value is a a dictionary with a frequency of 28 [veh/hr] for all routes
        &#34;&#34;&#34;

        if frequency_routes is None:
            frequency_routes = defaultdict(float)

            for route in routes:
                frequency_routes[route.id] = route.mode.fini

        # list with all city_nodes
        city_nodes = self.build_city_nodes(graph_obj)

        # assistant dictionary to build stop_nodes and routes_nodes: dic[city_node][mode_obj] = [list of routes]
        tree_graph = self.build_tree_graph(routes, city_nodes)

        # list with all stop nodes, there are 1 stop_node for each mode transiting in a city_node
        stop_nodes = self.build_stop_nodes(tree_graph)

        # list with all route_nodes, there are 1 route_node connected to a stop_node for each route in a city_node
        route_nodes = self.build_route_nodes(routes, stop_nodes)

        # extended graph nodes like as a dictionary: dic[city_node][stop_node] = [list route_nodes]
        self.__extended_graph_nodes = self.build_extended_graph_nodes(route_nodes)

        # list with all access edges, edges between city_node&lt;-&gt;stop_node
        access_edges = self.build_access_edges(self.__extended_graph_nodes)
        # list with all boarding edges, edges between stop_node-&gt;route_node
        boarding_edges = self.build_boarding_edges(self.__extended_graph_nodes, frequency_routes)
        # list with all alighting edges, edges between route_node-&gt;stop_node
        alighting_edges = self.build_alighting_edges(self.__extended_graph_nodes, TP)
        # list with all routes edges, edges between route_node(i-1)-&gt;route_node(i)
        routes_edges = self.build_route_edges(self.__extended_graph_nodes)

        self.__extended_graph_edges = []

        for edge in access_edges:
            self.__extended_graph_edges.append(edge)
        for edge in boarding_edges:
            self.__extended_graph_edges.append(edge)
        for edge in alighting_edges:
            self.__extended_graph_edges.append(edge)
        for edge in routes_edges:
            self.__extended_graph_edges.append(edge)

    def __str__(self):
        &#34;&#34;&#34;
        to print extended graph
        :return: String with information of the extended graph
        &#34;&#34;&#34;
        line = &#34;&#34;
        for city_node in self.__extended_graph_nodes:
            line += &#34;City node\n-Graph node name: {}\n&#34;.format(city_node.graph_node.name)
            for stop_node in self.__extended_graph_nodes[city_node]:
                # information about access edge
                for edge in self.__extended_graph_edges:
                    if edge.nodei == city_node and edge.nodej == stop_node:
                        line += &#34;\tAccess edge\n\t-Access time: {:.2f} [min]\n&#34;.format(edge.t)

                line += &#34;\t\tStop node\n\t\t-Mode name: {}\n&#34;.format(stop_node.mode.name)

                for route_node in self.__extended_graph_nodes[city_node][stop_node]:
                    # information about boarding edge
                    for edge in self.__extended_graph_edges:
                        if edge.nodei == stop_node and edge.nodej == route_node:
                            line += &#34;\t\t\tBoarding edge\n\t\t\t-Frequency: {:.2f} [veh/h]\n&#34;.format(edge.f)

                    # information about boarding edge
                    for edge in self.__extended_graph_edges:
                        if edge.nodei == route_node and edge.nodej == stop_node:
                            line += &#34;\t\t\tAlighting edge\n\t\t\t-Penalty transfer: {:.2f} [min]\n&#34;.format(edge.t * 60)

                    # information about route node
                    if route_node.prev_route_node is None:
                        line += &#34;\t\t\t\tRoute node\n\t\t\t\t-Route_id: {}\n\t\t\t\t-Direction: {}\n\t\t\t\t-Previous stop: {}\n\t\t\t\t-Time to previous stop: {:.2f} [hrs]\n&#34;.format(
                            route_node.route.id,
                            route_node.direction, &#34;no data&#34;, 0)
                    else:
                        t = 0
                        for edge in self.__extended_graph_edges:
                            if edge.nodei == route_node.prev_route_node and edge.nodej == route_node:
                                t = edge.t
                                break
                        line += &#34;\t\t\t\tRoute node\n\t\t\t\t-Route_id: {}\n\t\t\t\t-Direction: {}\n\t\t\t\t-Previous stop: {}\n\t\t\t\t-Time to previous stop: {} [hrs]\n&#34;.format(
                            route_node.route.id,
                            route_node.direction,
                            route_node.prev_route_node.stop_node.city_node.graph_node.name,
                            t)
        return line

    def get_extended_graph_nodes(self) -&gt; defaultdict2_route_node:
        &#34;&#34;&#34;
        to get extended nodes associated to the graph
        :return: dictionary: dic[CityNode][StopNode] = List[RouteNode]
        &#34;&#34;&#34;
        return self.__extended_graph_nodes

    def get_extended_graph_edges(self) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to get extended edges associated to the graph
        :return: List[ExtendedEdges]
        &#34;&#34;&#34;
        return self.__extended_graph_edges

    @staticmethod
    def build_city_nodes(graph_obj: Graph) -&gt; List[CityNode]:
        &#34;&#34;&#34;
        to build CityNodes in the extended graph
        :param graph_obj: Graph object
        :return: List[CityNode]
        &#34;&#34;&#34;
        city_nodes = []
        for node in graph_obj.get_nodes():
            city_node = CityNode(len(city_nodes), node)
            city_nodes.append(city_node)
        return city_nodes

    @staticmethod
    def build_tree_graph(routes: List[Route], city_nodes: List[CityNode]) -&gt; defaultdict2_route_direction:
        &#34;&#34;&#34;
        to build auxiliary structure for construction of the extended graph
        :param routes: routes in the network associated
        :param city_nodes: List[CityNode]
        :return: dictionary: dic[CityNode][TransportMode] = List(Route, direction = &#34;I&#34; or &#34;R&#34;)
        &#34;&#34;&#34;

        tree_graph = defaultdict(lambda: defaultdict(list))
        for city_node in city_nodes:
            node_graph_id = city_node.graph_node.id

            for route in routes:
                mode_obj = route.mode
                stops_i = route.stops_sequence_i
                stops_r = route.stops_sequence_r

                for stop in stops_i:
                    if str(node_graph_id) == str(stop):
                        # to avoid add twice first and last node in circular routes
                        if route._type == RouteType.PREDEFINED or route._type == RouteType.CIRCULAR:
                            if (route, &#34;I&#34;) not in tree_graph[city_node][mode_obj]:
                                tree_graph[city_node][mode_obj].append((route, &#34;I&#34;))
                        else:
                            tree_graph[city_node][mode_obj].append((route, &#34;I&#34;))

                for stop in stops_r:
                    if str(node_graph_id) == str(stop):
                        # to avoid add twice first and last node in circular routes
                        if route._type == RouteType.PREDEFINED or route._type == RouteType.CIRCULAR:
                            if (route, &#34;R&#34;) not in tree_graph[city_node][mode_obj]:
                                tree_graph[city_node][mode_obj].append((route, &#34;R&#34;))
                        else:
                            tree_graph[city_node][mode_obj].append((route, &#34;R&#34;))

        return tree_graph

    @staticmethod
    def build_stop_nodes(tree_graph: defaultdict2_route_direction) -&gt; List[StopNode]:
        &#34;&#34;&#34;
        to build StopNode in extended graph
        :param tree_graph: dic[CityNode][TransportMode] = List(Route, direction = &#34;I&#34; or &#34;R&#34;)
        :return: List[StopNode]
        &#34;&#34;&#34;
        # list with tuples (mode_obj, city_node) to not duplicated more of a stop for each mode in a city_node
        mode_city = []
        stop_nodes = []
        for city_node in tree_graph:
            for mode_obj in tree_graph[city_node]:
                if (mode_obj, city_node) not in mode_city:
                    mode_city.append((mode_obj, city_node))
                    stop_node = StopNode(len(stop_nodes), mode_obj, city_node)
                    stop_nodes.append(stop_node)
        return stop_nodes

    @staticmethod
    def build_route_nodes(routes: List[Route], stop_nodes: List[StopNode]) -&gt; List[RouteNode]:
        &#34;&#34;&#34;
        to build route nodes in extended graph
        :param routes: list of routes in network associated
        :param stop_nodes: List[StopNode]
        :return: List[RouteNode]
        &#34;&#34;&#34;
        # list with all route nodes
        route_nodes = []
        for route in routes:
            mode = route.mode
            stop_i = route.stops_sequence_i
            stop_r = route.stops_sequence_r
            # to circular exceptions
            _type = route._type

            # nodes for &#34;I&#34; direction
            nodes = []
            prev_route_node = None
            # look for a previous route node
            for stop in stop_i:
                stop_node = None
                for s in stop_nodes:
                    if s.mode == mode and str(s.city_node.graph_node.id) == str(stop):
                        stop_node = s
                        break
                route_node = RouteNode(len(route_nodes) + len(nodes), route, &#34;I&#34;, stop_node, prev_route_node)
                prev_route_node = route_node
                nodes.append(route_node)
            # add previous node_route in circular routes
            if prev_route_node is not None and _type == RouteType.CIRCULAR:
                for i in range(len(nodes)):
                    if i == 0:
                        continue
                    n = nodes[i]
                    if i == 1:
                        n.prev_route_node = nodes[len(nodes) - 1]
                        route_nodes.append(n)
                        continue
                    n = nodes[i]
                    route_nodes.append(n)
            # add previous node_route
            if _type == RouteType.PREDEFINED or _type == RouteType.CUSTOM:
                for n in nodes:
                    route_nodes.append(n)
            # nodes for &#34;R&#34; direction
            nodes = []
            prev_route_node = None
            # look for a previous route node
            for stop in stop_r:
                stop_node = None
                for s in stop_nodes:
                    if s.mode == mode and str(s.city_node.graph_node.id) == str(stop):
                        stop_node = s
                        break
                route_node = RouteNode(len(route_nodes) + len(nodes), route, &#34;R&#34;, stop_node, prev_route_node)
                prev_route_node = route_node
                nodes.append(route_node)
            # add previous node_route in circular routes
            if prev_route_node is not None and _type == RouteType.CIRCULAR:
                for i in range(len(nodes)):
                    if i == 0:
                        continue
                    n = nodes[i]
                    if i == 1:
                        n.prev_route_node = nodes[len(nodes) - 1]
                        route_nodes.append(n)
                        continue
                    n = nodes[i]
                    route_nodes.append(n)
            # add previous node_route
            if _type == RouteType.PREDEFINED or _type == RouteType.CUSTOM:
                for n in nodes:
                    route_nodes.append(n)

        return route_nodes

    @staticmethod
    def build_extended_graph_nodes(route_nodes: List[RouteNode]) -&gt; defaultdict2_route_node:
        &#34;&#34;&#34;
        to build extended graph node structure
        :param route_nodes: List[RouteNode]
        :return: dictionary: dic[CityNode][StopNode] = List[RouteNode]
        &#34;&#34;&#34;

        extended_graph_nodes = defaultdict(lambda: defaultdict(list))
        for route_node in route_nodes:
            stop_node = route_node.stop_node
            city_node = stop_node.city_node
            extended_graph_nodes[city_node][stop_node].append(route_node)

        return extended_graph_nodes

    @staticmethod
    def build_access_edges(extended_graph_nodes: defaultdict2_route_node) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build access edges in extended graph
        :param extended_graph_nodes: dictionary: dic[CityNode][StopNode] = List[RouteNode]
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;
        access_edges = []
        for city_node in extended_graph_nodes:
            for stop_node in extended_graph_nodes[city_node]:
                edge1 = ExtendedEdge(len(access_edges), city_node, stop_node,
                                     stop_node.mode.tat / 60, float(&#39;inf&#39;), ExtendedEdgesType.ACCESS)
                access_edges.append(edge1)
                edge2 = ExtendedEdge(len(access_edges), stop_node, city_node,
                                     stop_node.mode.tat / 60, float(&#39;inf&#39;), ExtendedEdgesType.ACCESS)
                access_edges.append(edge2)
        return access_edges

    @staticmethod
    def build_boarding_edges(extended_graph_nodes: defaultdict2_route_node, frequency_routes: defaultdict_float) -&gt; \
            List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build boarding edges in extended graph
        :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
        :param frequency_routes: defauldict(float) with key: route_id and value: frequency [veh/hr] of the route_id.
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;
        boarding_edges = []
        for city_node in extended_graph_nodes:
            for stop_node in extended_graph_nodes[city_node]:
                for route_node in extended_graph_nodes[city_node][stop_node]:
                    route = route_node.route
                    direction = route_node.direction

                    if direction == &#34;I&#34;:
                        node_sequence = route.nodes_sequence_i
                    else:
                        node_sequence = route.nodes_sequence_r
                    # if not be last stop of the route add boarding edges
                    if route._type != RouteType.CIRCULAR and str(route_node.stop_node.city_node.graph_node.id) != str(
                            node_sequence[len(node_sequence) - 1]):
                        edge = ExtendedEdge(len(boarding_edges), stop_node, route_node,
                                            0, frequency_routes[route.id] / route.mode.d, ExtendedEdgesType.BOARDING)
                        boarding_edges.append(edge)
                        continue
                    # but if route type is circular add always boarding edges
                    if route._type == RouteType.CIRCULAR:
                        edge = ExtendedEdge(len(boarding_edges), stop_node, route_node,
                                            0, frequency_routes[route.id] / route.mode.d, ExtendedEdgesType.BOARDING)
                        boarding_edges.append(edge)
                        continue

        return boarding_edges

    @staticmethod
    def build_alighting_edges(extended_graph_nodes: defaultdict2_route_node, sPTP: float) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build extended alighting edges
        :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
        :param sPTP: penalty of the transfer of the passenger in EIV
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;
        spt = sPTP / 60
        alighting_edges = []
        for city_node in extended_graph_nodes:
            for stop_node in extended_graph_nodes[city_node]:
                for route_node in extended_graph_nodes[city_node][stop_node]:
                    route = route_node.route
                    direction = route_node.direction
                    if direction == &#34;I&#34;:
                        node_sequence = route.nodes_sequence_i
                    else:
                        node_sequence = route.nodes_sequence_r
                    # if not be first stop of the route add alighting edges
                    if route._type != RouteType.CIRCULAR and str(route_node.stop_node.city_node.graph_node.id) != str(
                            node_sequence[0]):
                        edge = ExtendedEdge(len(alighting_edges), route_node, stop_node,
                                            spt, float(&#39;inf&#39;), ExtendedEdgesType.ALIGHTING)
                        alighting_edges.append(edge)
                        continue
                    # but if route type is circular add always alighting edges
                    if route._type == RouteType.CIRCULAR:
                        edge = ExtendedEdge(len(alighting_edges), route_node, stop_node,
                                            spt, float(&#39;inf&#39;), ExtendedEdgesType.ALIGHTING)
                        alighting_edges.append(edge)
                        continue

        return alighting_edges

    @staticmethod
    def build_route_edges(extended_graph_nodes: defaultdict2_route_node) -&gt; List[ExtendedEdge]:
        &#34;&#34;&#34;
        to build extended routes edges
        :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
        :return: List[ExtendedEdge]
        &#34;&#34;&#34;

        route_nodes = []
        nodes = []

        for city_node in extended_graph_nodes:
            nodes.append(city_node.graph_node)
            for stop_node in extended_graph_nodes[city_node]:
                for route_node in extended_graph_nodes[city_node][stop_node]:
                    route_nodes.append(route_node)

        route_edges = []
        for route_node in route_nodes:
            # only if route node has previous route node
            if route_node.prev_route_node is not None:

                # previous route node
                previous_route_node = route_node.prev_route_node

                # to identify route
                route = route_node.route
                direction = route_node.direction

                # velocity of the route
                v = route_node.stop_node.mode.v

                # id graph node to actual route node and previous route node
                id_city1 = route_node.stop_node.city_node.graph_node.id
                id_city2 = previous_route_node.stop_node.city_node.graph_node.id

                # to identify node sequence of the route
                if direction == &#34;I&#34;:
                    node_sequence = route.nodes_sequence_i
                else:
                    node_sequence = route.nodes_sequence_r

                # to get distance between actual route node and previous route node
                distance = 0
                x_prev = previous_route_node.stop_node.city_node.graph_node.x
                y_prev = previous_route_node.stop_node.city_node.graph_node.y
                x_final = route_node.stop_node.city_node.graph_node.x
                y_final = route_node.stop_node.city_node.graph_node.y
                count = False
                for node in node_sequence:
                    if str(node) == str(id_city2):
                        count = True
                        continue
                    if str(node) == str(id_city1):
                        distance = distance + ((x_prev - x_final) ** 2 + (y_prev - y_final) ** 2) ** 0.5
                        break
                    if count:
                        for n in nodes:
                            if str(node) == str(n.id):
                                x = n.x
                                y = n.y
                                distance = distance + ((x_prev - x) ** 2 + (y_prev - y) ** 2) ** 0.5
                                x_prev = x
                                y_prev = y
                                break

                t = distance / v

                edge = ExtendedEdge(len(route_edges), previous_route_node, route_node,
                                    t, float(&#39;inf&#39;), ExtendedEdgesType.ROUTE)
                route_edges.append(edge)
        return route_edges</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_access_edges"><code class="name flex">
<span>def <span class="ident">build_access_edges</span></span>(<span>extended_graph_nodes: defaultdict(<function <lambda> at 0x10624A98>, {})) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdge" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdge">ExtendedEdge</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to build access edges in extended graph
:param extended_graph_nodes: dictionary: dic[CityNode][StopNode] = List[RouteNode]
:return: List[ExtendedEdge]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_access_edges(extended_graph_nodes: defaultdict2_route_node) -&gt; List[ExtendedEdge]:
    &#34;&#34;&#34;
    to build access edges in extended graph
    :param extended_graph_nodes: dictionary: dic[CityNode][StopNode] = List[RouteNode]
    :return: List[ExtendedEdge]
    &#34;&#34;&#34;
    access_edges = []
    for city_node in extended_graph_nodes:
        for stop_node in extended_graph_nodes[city_node]:
            edge1 = ExtendedEdge(len(access_edges), city_node, stop_node,
                                 stop_node.mode.tat / 60, float(&#39;inf&#39;), ExtendedEdgesType.ACCESS)
            access_edges.append(edge1)
            edge2 = ExtendedEdge(len(access_edges), stop_node, city_node,
                                 stop_node.mode.tat / 60, float(&#39;inf&#39;), ExtendedEdgesType.ACCESS)
            access_edges.append(edge2)
    return access_edges</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_alighting_edges"><code class="name flex">
<span>def <span class="ident">build_alighting_edges</span></span>(<span>extended_graph_nodes: defaultdict(<function <lambda> at 0x10624A98>, {}), sPTP: float) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdge" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdge">ExtendedEdge</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to build extended alighting edges
:param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
:param sPTP: penalty of the transfer of the passenger in EIV
:return: List[ExtendedEdge]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_alighting_edges(extended_graph_nodes: defaultdict2_route_node, sPTP: float) -&gt; List[ExtendedEdge]:
    &#34;&#34;&#34;
    to build extended alighting edges
    :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
    :param sPTP: penalty of the transfer of the passenger in EIV
    :return: List[ExtendedEdge]
    &#34;&#34;&#34;
    spt = sPTP / 60
    alighting_edges = []
    for city_node in extended_graph_nodes:
        for stop_node in extended_graph_nodes[city_node]:
            for route_node in extended_graph_nodes[city_node][stop_node]:
                route = route_node.route
                direction = route_node.direction
                if direction == &#34;I&#34;:
                    node_sequence = route.nodes_sequence_i
                else:
                    node_sequence = route.nodes_sequence_r
                # if not be first stop of the route add alighting edges
                if route._type != RouteType.CIRCULAR and str(route_node.stop_node.city_node.graph_node.id) != str(
                        node_sequence[0]):
                    edge = ExtendedEdge(len(alighting_edges), route_node, stop_node,
                                        spt, float(&#39;inf&#39;), ExtendedEdgesType.ALIGHTING)
                    alighting_edges.append(edge)
                    continue
                # but if route type is circular add always alighting edges
                if route._type == RouteType.CIRCULAR:
                    edge = ExtendedEdge(len(alighting_edges), route_node, stop_node,
                                        spt, float(&#39;inf&#39;), ExtendedEdgesType.ALIGHTING)
                    alighting_edges.append(edge)
                    continue

    return alighting_edges</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_boarding_edges"><code class="name flex">
<span>def <span class="ident">build_boarding_edges</span></span>(<span>extended_graph_nodes: defaultdict(<function <lambda> at 0x10624A98>, {}), frequency_routes: defaultdict(<class 'float'>, {})) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdge" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdge">ExtendedEdge</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to build boarding edges in extended graph
:param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
:param frequency_routes: defauldict(float) with key: route_id and value: frequency [veh/hr] of the route_id.
:return: List[ExtendedEdge]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_boarding_edges(extended_graph_nodes: defaultdict2_route_node, frequency_routes: defaultdict_float) -&gt; \
        List[ExtendedEdge]:
    &#34;&#34;&#34;
    to build boarding edges in extended graph
    :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
    :param frequency_routes: defauldict(float) with key: route_id and value: frequency [veh/hr] of the route_id.
    :return: List[ExtendedEdge]
    &#34;&#34;&#34;
    boarding_edges = []
    for city_node in extended_graph_nodes:
        for stop_node in extended_graph_nodes[city_node]:
            for route_node in extended_graph_nodes[city_node][stop_node]:
                route = route_node.route
                direction = route_node.direction

                if direction == &#34;I&#34;:
                    node_sequence = route.nodes_sequence_i
                else:
                    node_sequence = route.nodes_sequence_r
                # if not be last stop of the route add boarding edges
                if route._type != RouteType.CIRCULAR and str(route_node.stop_node.city_node.graph_node.id) != str(
                        node_sequence[len(node_sequence) - 1]):
                    edge = ExtendedEdge(len(boarding_edges), stop_node, route_node,
                                        0, frequency_routes[route.id] / route.mode.d, ExtendedEdgesType.BOARDING)
                    boarding_edges.append(edge)
                    continue
                # but if route type is circular add always boarding edges
                if route._type == RouteType.CIRCULAR:
                    edge = ExtendedEdge(len(boarding_edges), stop_node, route_node,
                                        0, frequency_routes[route.id] / route.mode.d, ExtendedEdgesType.BOARDING)
                    boarding_edges.append(edge)
                    continue

    return boarding_edges</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_city_nodes"><code class="name flex">
<span>def <span class="ident">build_city_nodes</span></span>(<span>graph_obj: <a title="sidermit.city.graph.Graph" href="../../city/graph.html#sidermit.city.graph.Graph">Graph</a>) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.CityNode" href="#sidermit.optimization.preoptimization.extended_graph.CityNode">CityNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to build CityNodes in the extended graph
:param graph_obj: Graph object
:return: List[CityNode]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_city_nodes(graph_obj: Graph) -&gt; List[CityNode]:
    &#34;&#34;&#34;
    to build CityNodes in the extended graph
    :param graph_obj: Graph object
    :return: List[CityNode]
    &#34;&#34;&#34;
    city_nodes = []
    for node in graph_obj.get_nodes():
        city_node = CityNode(len(city_nodes), node)
        city_nodes.append(city_node)
    return city_nodes</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_extended_graph_nodes"><code class="name flex">
<span>def <span class="ident">build_extended_graph_nodes</span></span>(<span>route_nodes: List[<a title="sidermit.optimization.preoptimization.extended_graph.RouteNode" href="#sidermit.optimization.preoptimization.extended_graph.RouteNode">RouteNode</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>to build extended graph node structure
:param route_nodes: List[RouteNode]
:return: dictionary: dic[CityNode][StopNode] = List[RouteNode]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_extended_graph_nodes(route_nodes: List[RouteNode]) -&gt; defaultdict2_route_node:
    &#34;&#34;&#34;
    to build extended graph node structure
    :param route_nodes: List[RouteNode]
    :return: dictionary: dic[CityNode][StopNode] = List[RouteNode]
    &#34;&#34;&#34;

    extended_graph_nodes = defaultdict(lambda: defaultdict(list))
    for route_node in route_nodes:
        stop_node = route_node.stop_node
        city_node = stop_node.city_node
        extended_graph_nodes[city_node][stop_node].append(route_node)

    return extended_graph_nodes</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_route_edges"><code class="name flex">
<span>def <span class="ident">build_route_edges</span></span>(<span>extended_graph_nodes: defaultdict(<function <lambda> at 0x10624A98>, {})) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdge" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdge">ExtendedEdge</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to build extended routes edges
:param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
:return: List[ExtendedEdge]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_route_edges(extended_graph_nodes: defaultdict2_route_node) -&gt; List[ExtendedEdge]:
    &#34;&#34;&#34;
    to build extended routes edges
    :param extended_graph_nodes: dic[CityNode][StopNode] = List[RouteNode]
    :return: List[ExtendedEdge]
    &#34;&#34;&#34;

    route_nodes = []
    nodes = []

    for city_node in extended_graph_nodes:
        nodes.append(city_node.graph_node)
        for stop_node in extended_graph_nodes[city_node]:
            for route_node in extended_graph_nodes[city_node][stop_node]:
                route_nodes.append(route_node)

    route_edges = []
    for route_node in route_nodes:
        # only if route node has previous route node
        if route_node.prev_route_node is not None:

            # previous route node
            previous_route_node = route_node.prev_route_node

            # to identify route
            route = route_node.route
            direction = route_node.direction

            # velocity of the route
            v = route_node.stop_node.mode.v

            # id graph node to actual route node and previous route node
            id_city1 = route_node.stop_node.city_node.graph_node.id
            id_city2 = previous_route_node.stop_node.city_node.graph_node.id

            # to identify node sequence of the route
            if direction == &#34;I&#34;:
                node_sequence = route.nodes_sequence_i
            else:
                node_sequence = route.nodes_sequence_r

            # to get distance between actual route node and previous route node
            distance = 0
            x_prev = previous_route_node.stop_node.city_node.graph_node.x
            y_prev = previous_route_node.stop_node.city_node.graph_node.y
            x_final = route_node.stop_node.city_node.graph_node.x
            y_final = route_node.stop_node.city_node.graph_node.y
            count = False
            for node in node_sequence:
                if str(node) == str(id_city2):
                    count = True
                    continue
                if str(node) == str(id_city1):
                    distance = distance + ((x_prev - x_final) ** 2 + (y_prev - y_final) ** 2) ** 0.5
                    break
                if count:
                    for n in nodes:
                        if str(node) == str(n.id):
                            x = n.x
                            y = n.y
                            distance = distance + ((x_prev - x) ** 2 + (y_prev - y) ** 2) ** 0.5
                            x_prev = x
                            y_prev = y
                            break

            t = distance / v

            edge = ExtendedEdge(len(route_edges), previous_route_node, route_node,
                                t, float(&#39;inf&#39;), ExtendedEdgesType.ROUTE)
            route_edges.append(edge)
    return route_edges</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_route_nodes"><code class="name flex">
<span>def <span class="ident">build_route_nodes</span></span>(<span>routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], stop_nodes: List[<a title="sidermit.optimization.preoptimization.extended_graph.StopNode" href="#sidermit.optimization.preoptimization.extended_graph.StopNode">StopNode</a>]) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.RouteNode" href="#sidermit.optimization.preoptimization.extended_graph.RouteNode">RouteNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to build route nodes in extended graph
:param routes: list of routes in network associated
:param stop_nodes: List[StopNode]
:return: List[RouteNode]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_route_nodes(routes: List[Route], stop_nodes: List[StopNode]) -&gt; List[RouteNode]:
    &#34;&#34;&#34;
    to build route nodes in extended graph
    :param routes: list of routes in network associated
    :param stop_nodes: List[StopNode]
    :return: List[RouteNode]
    &#34;&#34;&#34;
    # list with all route nodes
    route_nodes = []
    for route in routes:
        mode = route.mode
        stop_i = route.stops_sequence_i
        stop_r = route.stops_sequence_r
        # to circular exceptions
        _type = route._type

        # nodes for &#34;I&#34; direction
        nodes = []
        prev_route_node = None
        # look for a previous route node
        for stop in stop_i:
            stop_node = None
            for s in stop_nodes:
                if s.mode == mode and str(s.city_node.graph_node.id) == str(stop):
                    stop_node = s
                    break
            route_node = RouteNode(len(route_nodes) + len(nodes), route, &#34;I&#34;, stop_node, prev_route_node)
            prev_route_node = route_node
            nodes.append(route_node)
        # add previous node_route in circular routes
        if prev_route_node is not None and _type == RouteType.CIRCULAR:
            for i in range(len(nodes)):
                if i == 0:
                    continue
                n = nodes[i]
                if i == 1:
                    n.prev_route_node = nodes[len(nodes) - 1]
                    route_nodes.append(n)
                    continue
                n = nodes[i]
                route_nodes.append(n)
        # add previous node_route
        if _type == RouteType.PREDEFINED or _type == RouteType.CUSTOM:
            for n in nodes:
                route_nodes.append(n)
        # nodes for &#34;R&#34; direction
        nodes = []
        prev_route_node = None
        # look for a previous route node
        for stop in stop_r:
            stop_node = None
            for s in stop_nodes:
                if s.mode == mode and str(s.city_node.graph_node.id) == str(stop):
                    stop_node = s
                    break
            route_node = RouteNode(len(route_nodes) + len(nodes), route, &#34;R&#34;, stop_node, prev_route_node)
            prev_route_node = route_node
            nodes.append(route_node)
        # add previous node_route in circular routes
        if prev_route_node is not None and _type == RouteType.CIRCULAR:
            for i in range(len(nodes)):
                if i == 0:
                    continue
                n = nodes[i]
                if i == 1:
                    n.prev_route_node = nodes[len(nodes) - 1]
                    route_nodes.append(n)
                    continue
                n = nodes[i]
                route_nodes.append(n)
        # add previous node_route
        if _type == RouteType.PREDEFINED or _type == RouteType.CUSTOM:
            for n in nodes:
                route_nodes.append(n)

    return route_nodes</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_stop_nodes"><code class="name flex">
<span>def <span class="ident">build_stop_nodes</span></span>(<span>tree_graph: defaultdict(<function <lambda> at 0x10624C48>, {})) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.StopNode" href="#sidermit.optimization.preoptimization.extended_graph.StopNode">StopNode</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to build StopNode in extended graph
:param tree_graph: dic[CityNode][TransportMode] = List(Route, direction = "I" or "R")
:return: List[StopNode]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_stop_nodes(tree_graph: defaultdict2_route_direction) -&gt; List[StopNode]:
    &#34;&#34;&#34;
    to build StopNode in extended graph
    :param tree_graph: dic[CityNode][TransportMode] = List(Route, direction = &#34;I&#34; or &#34;R&#34;)
    :return: List[StopNode]
    &#34;&#34;&#34;
    # list with tuples (mode_obj, city_node) to not duplicated more of a stop for each mode in a city_node
    mode_city = []
    stop_nodes = []
    for city_node in tree_graph:
        for mode_obj in tree_graph[city_node]:
            if (mode_obj, city_node) not in mode_city:
                mode_city.append((mode_obj, city_node))
                stop_node = StopNode(len(stop_nodes), mode_obj, city_node)
                stop_nodes.append(stop_node)
    return stop_nodes</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_tree_graph"><code class="name flex">
<span>def <span class="ident">build_tree_graph</span></span>(<span>routes: List[<a title="sidermit.publictransportsystem.network.Route" href="../../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>], city_nodes: List[<a title="sidermit.optimization.preoptimization.extended_graph.CityNode" href="#sidermit.optimization.preoptimization.extended_graph.CityNode">CityNode</a>])</span>
</code></dt>
<dd>
<div class="desc"><p>to build auxiliary structure for construction of the extended graph
:param routes: routes in the network associated
:param city_nodes: List[CityNode]
:return: dictionary: dic[CityNode][TransportMode] = List(Route, direction = "I" or "R")</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def build_tree_graph(routes: List[Route], city_nodes: List[CityNode]) -&gt; defaultdict2_route_direction:
    &#34;&#34;&#34;
    to build auxiliary structure for construction of the extended graph
    :param routes: routes in the network associated
    :param city_nodes: List[CityNode]
    :return: dictionary: dic[CityNode][TransportMode] = List(Route, direction = &#34;I&#34; or &#34;R&#34;)
    &#34;&#34;&#34;

    tree_graph = defaultdict(lambda: defaultdict(list))
    for city_node in city_nodes:
        node_graph_id = city_node.graph_node.id

        for route in routes:
            mode_obj = route.mode
            stops_i = route.stops_sequence_i
            stops_r = route.stops_sequence_r

            for stop in stops_i:
                if str(node_graph_id) == str(stop):
                    # to avoid add twice first and last node in circular routes
                    if route._type == RouteType.PREDEFINED or route._type == RouteType.CIRCULAR:
                        if (route, &#34;I&#34;) not in tree_graph[city_node][mode_obj]:
                            tree_graph[city_node][mode_obj].append((route, &#34;I&#34;))
                    else:
                        tree_graph[city_node][mode_obj].append((route, &#34;I&#34;))

            for stop in stops_r:
                if str(node_graph_id) == str(stop):
                    # to avoid add twice first and last node in circular routes
                    if route._type == RouteType.PREDEFINED or route._type == RouteType.CIRCULAR:
                        if (route, &#34;R&#34;) not in tree_graph[city_node][mode_obj]:
                            tree_graph[city_node][mode_obj].append((route, &#34;R&#34;))
                    else:
                        tree_graph[city_node][mode_obj].append((route, &#34;R&#34;))

    return tree_graph</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.get_extended_graph_edges"><code class="name flex">
<span>def <span class="ident">get_extended_graph_edges</span></span>(<span>self) ‑> List[<a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdge" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdge">ExtendedEdge</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>to get extended edges associated to the graph
:return: List[ExtendedEdges]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extended_graph_edges(self) -&gt; List[ExtendedEdge]:
    &#34;&#34;&#34;
    to get extended edges associated to the graph
    :return: List[ExtendedEdges]
    &#34;&#34;&#34;
    return self.__extended_graph_edges</code></pre>
</details>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.get_extended_graph_nodes"><code class="name flex">
<span>def <span class="ident">get_extended_graph_nodes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>to get extended nodes associated to the graph
:return: dictionary: dic[CityNode][StopNode] = List[RouteNode]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_extended_graph_nodes(self) -&gt; defaultdict2_route_node:
    &#34;&#34;&#34;
    to get extended nodes associated to the graph
    :return: dictionary: dic[CityNode][StopNode] = List[RouteNode]
    &#34;&#34;&#34;
    return self.__extended_graph_nodes</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.ExtendedNode"><code class="flex name class">
<span>class <span class="ident">ExtendedNode</span></span>
<span>(</span><span>extendend_node_id)</span>
</code></dt>
<dd>
<div class="desc"><p>node to extended graph
:param extendend_node_id: node id</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ExtendedNode:

    def __init__(self, extendend_node_id):
        &#34;&#34;&#34;
        node to extended graph
        :param extendend_node_id: node id
        &#34;&#34;&#34;
        self.id = extendend_node_id</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="sidermit.optimization.preoptimization.extended_graph.CityNode" href="#sidermit.optimization.preoptimization.extended_graph.CityNode">CityNode</a></li>
<li><a title="sidermit.optimization.preoptimization.extended_graph.RouteNode" href="#sidermit.optimization.preoptimization.extended_graph.RouteNode">RouteNode</a></li>
<li><a title="sidermit.optimization.preoptimization.extended_graph.StopNode" href="#sidermit.optimization.preoptimization.extended_graph.StopNode">StopNode</a></li>
</ul>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.RouteNode"><code class="flex name class">
<span>class <span class="ident">RouteNode</span></span>
<span>(</span><span>route_node_id, route_obj: <a title="sidermit.publictransportsystem.network.Route" href="../../publictransportsystem/network.html#sidermit.publictransportsystem.network.Route">Route</a>, direction: str, stop_node: <a title="sidermit.optimization.preoptimization.extended_graph.StopNode" href="#sidermit.optimization.preoptimization.extended_graph.StopNode">StopNode</a>, previous=None)</span>
</code></dt>
<dd>
<div class="desc"><p>extended node with route information
:param route_node_id: node id
:param route_obj: Route object
:param direction: "I" if RouteNode represents forward direction, "R" if RouteNode represents return direction
:param stop_node: StopNode object associated
:param previous: previous RouteNode in stop sequences of the route associated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RouteNode(ExtendedNode):
    def __init__(self, route_node_id, route_obj: Route, direction: str, stop_node: StopNode, previous=None):
        &#34;&#34;&#34;
        extended node with route information
        :param route_node_id: node id
        :param route_obj: Route object
        :param direction: &#34;I&#34; if RouteNode represents forward direction, &#34;R&#34; if RouteNode represents return direction
        :param stop_node: StopNode object associated
        :param previous: previous RouteNode in stop sequences of the route associated
        &#34;&#34;&#34;
        ExtendedNode.__init__(self, route_node_id)
        self.route = route_obj
        self.direction = direction
        self.stop_node = stop_node
        self.prev_route_node = previous</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedNode" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedNode">ExtendedNode</a></li>
</ul>
</dd>
<dt id="sidermit.optimization.preoptimization.extended_graph.StopNode"><code class="flex name class">
<span>class <span class="ident">StopNode</span></span>
<span>(</span><span>stop_node_id, mode_obj: <a title="sidermit.publictransportsystem.mode.TransportMode" href="../../publictransportsystem/mode.html#sidermit.publictransportsystem.mode.TransportMode">TransportMode</a>, city_node: <a title="sidermit.optimization.preoptimization.extended_graph.CityNode" href="#sidermit.optimization.preoptimization.extended_graph.CityNode">CityNode</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>extended node with Transport Mode information
:param stop_node_id: node id
:param mode_obj: TransportMode object
:param city_node: CityNode object associated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class StopNode(ExtendedNode):
    def __init__(self, stop_node_id, mode_obj: TransportMode, city_node: CityNode):
        &#34;&#34;&#34;
        extended node with Transport Mode information
        :param stop_node_id: node id
        :param mode_obj: TransportMode object
        :param city_node: CityNode object associated
        &#34;&#34;&#34;
        ExtendedNode.__init__(self, stop_node_id)
        self.mode = mode_obj
        self.city_node = city_node</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedNode" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedNode">ExtendedNode</a></li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sidermit.optimization.preoptimization" href="index.html">sidermit.optimization.preoptimization</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sidermit.optimization.preoptimization.extended_graph.CityNode" href="#sidermit.optimization.preoptimization.extended_graph.CityNode">CityNode</a></code></h4>
</li>
<li>
<h4><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdge" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdge">ExtendedEdge</a></code></h4>
</li>
<li>
<h4><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType">ExtendedEdgesType</a></code></h4>
<ul class="">
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ACCESS" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ACCESS">ACCESS</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ALIGHTING" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ALIGHTING">ALIGHTING</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.BOARDING" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.BOARDING">BOARDING</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ROUTE" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedEdgesType.ROUTE">ROUTE</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph">ExtendedGraph</a></code></h4>
<ul class="">
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_access_edges" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_access_edges">build_access_edges</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_alighting_edges" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_alighting_edges">build_alighting_edges</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_boarding_edges" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_boarding_edges">build_boarding_edges</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_city_nodes" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_city_nodes">build_city_nodes</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_extended_graph_nodes" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_extended_graph_nodes">build_extended_graph_nodes</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_route_edges" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_route_edges">build_route_edges</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_route_nodes" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_route_nodes">build_route_nodes</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_stop_nodes" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_stop_nodes">build_stop_nodes</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_tree_graph" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.build_tree_graph">build_tree_graph</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.get_extended_graph_edges" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.get_extended_graph_edges">get_extended_graph_edges</a></code></li>
<li><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.get_extended_graph_nodes" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedGraph.get_extended_graph_nodes">get_extended_graph_nodes</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="sidermit.optimization.preoptimization.extended_graph.ExtendedNode" href="#sidermit.optimization.preoptimization.extended_graph.ExtendedNode">ExtendedNode</a></code></h4>
</li>
<li>
<h4><code><a title="sidermit.optimization.preoptimization.extended_graph.RouteNode" href="#sidermit.optimization.preoptimization.extended_graph.RouteNode">RouteNode</a></code></h4>
</li>
<li>
<h4><code><a title="sidermit.optimization.preoptimization.extended_graph.StopNode" href="#sidermit.optimization.preoptimization.extended_graph.StopNode">StopNode</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.1</a>.</p>
</footer>
</body>
</html>